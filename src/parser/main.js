"use strict";

// Parser:
// ✓ comments
// 	✓ single line
// 	✖ trailing-ending comments
// ✓ @settings
// ✓ command chains
// 	✓ shortcuts
// ✓ long-form flags
// 	✓ command-flags
// 	✓ flags options list

// ✖ balanced braces - necessary?
// ✖ validate characters for command chains
// ✖ account for line numbers/errors

// Needed modules.
// const path = require("path");
const chalk = require("chalk");
const { exit } = require("../utils.js");

// Require parser functions.
const config = require("./config.js");
const shortcuts = require("./shortcuts.js");
const dedupe = require("./dedupe.js");
const argparser = require("./argparser.js");
const paramparse = require("./paramparse.js");
const formatflags = require("./formatflags.js");
const merge = require("./merge.js");

module.exports = (contents, commandname, source) => {
	// Vars - General.
	let line = "";
	let line_count = 0;
	let indentation = "";
	let lookup = {};
	let settings = {};
	let newlines = [];

	let commandchain;
	let mflag;
	let mcommand;
	let line_type;
	let flag_set_oneline;

	let last_open_br = [];
	let last_open_pr = [];

	// RegExp patterns:
	// Letter.
	let r_letter = /[a-zA-Z]/;
	// Whitespace.
	let r_whitespace = /[ \t]/;
	// New line character.
	let r_nl = new RegExp(`(\\r?\\n)`);
	// Open command bracket.
	let r_open_command_br = /^\[\]?$/;
	// Close bracket.
	let r_close_br = /^[ \t]*\][ \t]*$/;
	// Close parentheses.
	let r_close_parens = /^[ \t]*\)[ \t]*$/;
	// Starting line character.
	let r_start_line_char = /[-@a-zA-Z\)\]#]/;
	// Command setter.
	let r_command_setter = /^[ \t]*=[ \t]*(\[|-{1,2})/;
	// Flag option.
	let r_flag_option = /^[ \t]*-[ \t]{1,}([^\s]{1,}.*?)$/;
	// Command.
	let r_command = new RegExp(`[-_.:a-zA-Z0-9\\\\\/{}\|]`);
	// Setting syntax.
	let r_setting = /^(@[a-zA-Z][_a-zA-Z]*)[ \t]*(=[ \t]*(.*?))?$/;
	// Flag set.
	let r_flag_set = /^(-{1,2})([a-zA-Z][-._:a-zA-Z0-9]*)[ \t]*((=\*?)[ \t]*(\(|\(\)|.*?)?)?$/;

	// acmap file header.
	let header = [
		`# THIS FILE IS AUTOGENERATED —— DO NOT EDIT FILE DIRECTLY.`,
		`# ${new Date()};${Date.now()}`,
		`# nodecliac definition mapfiles: ~/.nodecliac/defs/\n`
	];

	/**
	 * Does 1 of two things. Either looks ahead and captures all characters
	 *     until provided RegExp fails or captures all characters until
	 *     RegExp passed. The latter method may be used to capture all
	 *     characters for a line, for example.
	 *
	 * @param  {number} index - The index offset to start capturing/testing.
	 * @param  {string} input - The string to test.
	 * @param  {regexp} r - The RegExp object to test characters against.
	 * @param  {number} rcount - Optional amount of characters to capture.
	 * @return {object} - Object containing passing/failing chars and
	 *     starting/ending capture indices.
	 *
	 * Examples:
	 * - Return all chars until RegExp is matched. Example will return all
	 *     characters until newline char is found.
	 * lookahead(2, "Some text.", new RegExp("\\r?\\n"));
	 * - Return n chars (in this case 1) that match RegExp.
	 * lookahead(2, "Some text.", new RegExp("[a-zA-Z]"), 1);
	 */
	let lookahead = (index, input, r, rcount) => {
		let chars = []; // RegExp passing chars.
		let chars_str = ""; // chars in string form.
		let xchars = []; // RegExp excluded chars.
		let xchars_str = ""; // xchars in string form.
		let sindex, eindex;

		// Check if return character count was provided.
		let rexists = rcount !== undefined;

		// Start looping string at provided index offset.
		for (let i = index, l = input.length; i < l; i++) {
			// Cache current loop item.
			let char = input[i];

			if (rexists) {
				// Once counter hits 0 all needed characters were captured.
				if (!rcount) {
					break;
				}

				// Test current character against provided RegExp.
				if (r.test(char)) {
					// Set starting match index if not already set.
					if (!sindex) {
						sindex = i;
					}

					// If character passes RegExp then add to passed array.
					chars.push(char);
					// Append to string.
					chars_str += char;

					// Decrease counter.
					if (rexists) {
						rcount--;

						// Set ending match index.
						eindex = i;
					}
				} else {
					// Set starting match index if not already set.
					if (!sindex) {
						sindex = i;
					}

					// Set ending match index.
					eindex = i;

					// Store failing characters.
					xchars.push(char);
					// Append to string.
					xchars_str += char;

					// Exit loop once RegExp fails.
					break;
				}
			} else {
				// This will capture all chars until RegExp matches.

				// Test current character against provided RegExp.
				if (!r.test(char)) {
					// Set starting match index if not already set.
					if (!sindex) {
						sindex = i;
					}

					// If character fails RegExp add to passed array.
					chars.push(char);
					// Append to string.
					chars_str += char;
				} else {
					// Set ending match index.
					eindex = i;

					// Store passing match.
					xchars.push(char);
					// Append to string.
					xchars_str += char;

					// Once RegExp passes we break.
					break;
				}
			}
		}

		// If glob until method was used and the contents does not contain
		// the ending character then we set the end index to that of the
		// input's length.
		if (!eindex && !rexists) {
			eindex = input.length;
		}

		return {
			chars,
			xchars,
			indices: [sindex, eindex],
			chars_str,
			xchars_str
		};
	};

	// The index, source input, regexp, return character count.
	let error = (message, index) => {
		exit([
			`[${chalk.bold.red("error")}] ${message} [line ${line_count + 1}${
				index !== undefined ? `:${index}` : ""
			}]`
		]);
	};

	// The index, source input, regexp, return character count.
	let warning = (message, index, line) => {
		exit(
			[
				`[${chalk.bold.yellow("warning")}] ${message} [line ${(line ||
					line_count) + 1}${index !== undefined ? `:${index}` : ""}]`
			],
			false
		);
	};

	// Main loop. Loops over each character in acmap.
	for (let i = 0, l = contents.length; i < l; i++) {
		// Cache current/previous/next chars.
		let char = contents.charAt(i);
		let pchar = contents.charAt(i - 1);
		let nchar = contents.charAt(i + 1);

		// Check if \r?\n newline sequence.
		if ((char === "\r" && nchar === "\n") || char === "\n") {
			// Increment line counter.
			line_count++;

			// The line type will get switched to "command_setter" after
			// extracting the command chain. However, when the command chain
			// does not contain a setter and therefore also no flags the
			// command chain needs to be cleared to catch any flags not
			// contained within [].
			if (line_type === "command_setter") {
				commandchain = "";
			}

			// Reset vars.
			line = "";
			line_type = null;
			indentation = "";

			continue;
		}

		// If a line type has not been defined yet.
		if (!line_type) {
			// If the current character is a space then continue.
			if (r_whitespace.test(char)) {
				indentation += char;
				continue;
			}

			// If not a space character, look for an allowed character.
			// Lines can start with following chars/char sets.
			// @      → setting
			// #      → comment
			// a-zA-Z → command chain
			//     -      → flag
			//     '- '   → flag option (ignore quotes)
			//     )      → closing flag set
			//     ]      → closing long-flag form
			// -------------------------------------------------------------
			// Special flag characters to look out for:
			// $(, "", ''

			// Char must be an allowed starting char.
			if (!r_start_line_char.test(char)) {
				error(
					`${chalk.bold(
						"Syntax"
					)}: Invalid start-of-line character '${char}'.`,
					indentation.length
				);
			}

			// Set line start type.
			if (char === "@") {
				line_type = "setting";
			} else if (char === "#") {
				line_type = "comment";
			} else if (r_letter.test(char)) {
				line_type = "command";

				if (commandchain) {
					error("Command chain cannot be nested.");
				}
			} else if (char === "]") {
				line_type = "close_bracket";
			} else if (char === "-") {
				// If flag is set we are getting flag options.
				line_type = mflag
					? // Option must my listed with a hyphen.
					  // /\s/.test(nchar)
					  "flag_option"
					: "flag_set";

				// If command chain does not exist but a flag_set/option
				// was detected there is an unnested/unwrapped flag/option.
				if (!commandchain) {
					// Look ahead to grab setting line.
					let { indices, chars_str } = lookahead(i, contents, r_nl);

					if (/^-[ \t]/.test(chars_str)) {
						error("Improperly nested flag option.");
					} else if (/^-{1,2}/) {
						error("Improperly nested flag.");
					}

					// General error.
					error(
						"Rogue flag/flag option. Must be placed inside '[]'."
					);
				}
			} else if (char === ")") {
				line_type = "close_parenthesis";
			}

			// Following commands cannot begin with any whitespace.
			if (
				indentation.length &&
				["setting", "command"].includes(line_type)
			) {
				error(`Line cannot begin with whitespace.`, 0);
			}

			// line += char;
		}

		if (line_type) {
			if (line_type === "setting") {
				// Look ahead to grab setting line.
				let { indices, chars_str } = lookahead(i, contents, r_nl);

				// Checks:
				// - Empty setting.
				// - Invalid characters.
				// - Duplicate settings.
				// - Dangling setting symbol.
				// - Improperly quoted value.

				// [TODO] Simplify error checking.

				// Check for dandling setting symbol.
				if (chars_str === "@") {
					error("Dangling '@' setting symbol.", indentation.length);
				}
				// Breakdown setting (setting name/value).
				let matches = chars_str.match(r_setting);
				// No matches means setting name contains invalid characters.
				if (!matches) {
					// If '=' present check for invalid chars in setting name.
					let eq_sign_index = chars_str.indexOf("=");
					if (-~eq_sign_index) {
						// Get setting name.
						let name = chars_str.substring(0, eq_sign_index).trim();

						// Replace space/tab characters with their symbols.
						name = name.replace(/ |\t/g, function(match) {
							return match === " " ? "␣" : "⇥";
						});

						// Current line before char string.
						let cline = `${indentation}${line}`;

						// Keep invalid characters count for error message.
						let highlight_count = 0;
						let highlight_name =
							"@" +
							name
								.slice(1)
								.replace(/([^_a-zA-Z0-9])/g, function(match) {
									highlight_count++;
									return `${chalk.red.bold(match)}`;
								});

						// Highlight invalid chars.
						error(
							`Invalid character${
								highlight_count > 1 ? "s" : ""
							} in setting name '${highlight_name}'.`,
							cline.length
						);
					}

					// General error.
					error(
						`Invalid setting '${chalk.bold(
							"@" +
								chars_str
									.slice(1)
									// Replace space and tab characters with their symbols.
									.replace(/ |\t/g, function(match) {
										return match === " " ? "␣" : "⇥";
									})
									.replace(
										/([^a-zA-Z])/g,
										`${chalk.bold.red("$1")}`
									)
						)}'.`,
						indentation.length
					);
				}
				// Check that value if quoted is quoted properly.
				let name = matches[1];
				let value = matches[3];
				if (value) {
					// If value is quoted check that it's properly quoted.
					let vfchar = value.charAt(0);
					var vlchar = value.charAt(value.length - 1);

					// Check for mismatched quotes.
					if (/"|'/.test(vfchar) && /"|'/.test(vlchar)) {
						if (vfchar !== vlchar) {
							error(`Setting value has mismatched quotes.`);
						}
					}
					// Check that the last char is a matching quote.
					else if (/"|'/.test(vfchar) && vfchar !== vlchar) {
						error(
							`Improperly quoted setting value. Missing right ${vfchar} quote.`
						);
					}
					// Check that the last char is a matching quote.
					else if (/"|'/.test(vlchar) && vlchar !== vfchar) {
						error(
							`Improperly quoted setting value. Missing left ${vlchar} quote.`
						);
					}
				} else {
					error(`Valueless setting '${chalk.bold(matches[0])}'.`);
				}
				// Check if setting syntax is valid or give general error.
				if (!r_setting.test(chars_str)) {
					error(`Invalid setting.`, indentation.length);
				}

				// Else, checks passed so reset vars. Reset index to continue
				// loop at newline character on next iteration.
				i = indices[1] - 1;

				// If setting exists give an dupe/override warning.
				if (settings[name]) {
					warning(
						`Duplicate '${chalk.bold(name)}' setting.`,
						indentation.length
					);
				}

				// Store setting/value in settings object.
				settings[name] = value;
			} else if (line_type === "command") {
				// Look ahead to grab command chain.
				let { chars_str, indices } = lookahead(
					i,
					contents,
					r_command,
					Infinity
				);

				// Reset index to be at the end of the line.
				i = indices[1] - 1;

				// Next look for command setter (' = ' → ignore quotes).
				line_type = "command_setter";

				// Store chars.
				line += chars_str;

				// Store command chain.
				if (!lookup[line]) {
					lookup[line] = [];
				}
				commandchain = line;
			} else if (line_type === "command_setter") {
				// Look ahead to grab command chain.
				let { chars_str, indices } = lookahead(i, contents, r_nl);

				// Checks:
				// - Check for invalid characters.
				// - Highlight multiple '=' and '[' characters?
				// - Check for possible invalid characters.

				// Remove all whitespace from string.
				let stripped = chars_str.replace(/[ \t]/g, "");

				// Current line before char string.
				let cline = `${indentation}${line}`;

				// Must pass RegExp pattern.
				if (!r_command_setter.test(chars_str)) {
					// Check if setter was even provider.
					if (!stripped.startsWith("=")) {
						error("Missing '=' after command chain.", cline.length);
					}
					// Check if assignment is empty. Give warning for now
					// or be more strict and give error.
					else if (stripped === "=") {
						warning(`Empty assignment after '='.`);
						i = indices[1] - 1;
						continue;
					}
					// Check for missing '[' character?
					else if (!stripped.includes("[")) {
						error(`Illegal assignment after '='.`, cline.length);
					}

					// // Give general error.
					// error(
					// 	`Expected ' = [' but saw '${chars_str}' instead.`,
					// 	cline.length
					// );
				}

				// Store chars.
				line += chars_str;

				// Lookup RegExp char.
				let rchar;

				// Get setter type. Either [ or '--' for single line flags
				// to start a single line definition string.
				if (/^-/.test(chars_str.match(r_command_setter)[1])) {
					// Look ahead to grab '[' index.
					rchar = "-";

					line_type = "flag_set_oneline";
					flag_set_oneline = [chars_str, indices];
				} else {
					// Look ahead to grab '[' index.
					rchar = "\\[";

					// Next look for command open bracket. ('[' → ignore quotes).
					line_type = "command_open_bracket";
				}

				// Look ahead to grab lookup character index.
				let la = lookahead(0, chars_str, new RegExp(rchar));

				// Reset index to be at the end of the line.
				i = i + la.indices[1] - 1;
			} else if (line_type === "command_open_bracket") {
				// Unclosed '['.
				if (last_open_br.length) {
					line_count = last_open_br[0];
					error("Unclosed open bracket.");
				}

				// Look ahead to grab command chain.
				let { chars_str, indices } = lookahead(i, contents, r_nl);

				// Remove all whitespace from string.
				let stripped = chars_str.replace(/[ \t]/g, "");

				// Current line before char string.
				let cline = `${indentation}${line}`;

				// If brackets are empty give warning.
				if (stripped === "[]") {
					warning(`Empty '[]' (no flags).`);

					// Reset flags.
					mcommand = null;
					commandchain = "";
					last_open_br.length = 0;
				}

				// Must pass RegExp pattern.
				if (!r_open_command_br.test(stripped)) {
					// Check for trailing chars.
					error(
						`Illegal character${
							stripped.length - 1 ? "s" : ""
						} after '${/^\[\]/.test(stripped) ? "]" : "["}'.`
						// , cline.indexOf("[") + 1
					);
				}

				// If bracket is unclosed then set flag.
				if (stripped === "[") {
					// Store line of open bracket for later use in error.
					last_open_br = [line_count];
					mcommand = true;
				}

				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "flag_set_oneline") {
				// Get information stored from command_setter.
				let [chars_str, indices] = flag_set_oneline;

				// Remove setter syntax.
				chars_str = chars_str.replace(/^[ \t]*=[ \t]*/, "");

				let flags = chars_str
					// Parse on unescaped '|' characters:
					// [https://stackoverflow.com/a/25895905]
					// [https://stackoverflow.com/a/12281034]
					.split(/(?<=[^\\]|^|$)\|/);

				// Add to lookup table if not already.
				let chain = lookup[commandchain];
				if (chain) {
					for (let i = 0, l = flags.length; i < l; i++) {
						// Cache current loop item.
						let flag = flags[i].trim();

						// Skip empty flags.
						if (!/^-{1,}$/.test(flag)) {
							chain.push(flag);
						}
					}
				}

				// Clear values.
				commandchain = "";
				flag_set_oneline = null;

				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "flag_set") {
				// Look ahead to grab setting.
				let { chars_str, chars, indices } = lookahead(
					i,
					contents,
					r_nl
				);

				// Must pass RegExp pattern.
				if (!r_flag_set.test(chars_str)) {
					// Check if it's a flag option. If so the option is not
					// being assigned to a flag.
					if (r_flag_option.test(chars_str)) {
						error(`Unassigned flag option.`);
					}

					// General error.
					error(`Invalid flag.`);
				}

				// Breakdown flag.
				let [
					,
					hyphens,
					flag,
					,
					setter = "",
					value = ""
				] = chars_str.match(r_flag_set);

				// If value is a command-flag or an options value list
				// make sure both cases are properly enclosed with ')'.
				if (
					value &&
					/^\$?\(/.test(value) &&
					value
						.substring(value.indexOf("(") + 1, value.length)
						.replace(/\s/g, "").length &&
					chars[chars.length - 1] !== ")"
				) {
					if (value.charAt(0) === "$") {
						error("Unclosed command-flag. Add ')' to close line.");
					} else {
						error("Unclosed options flag. Add ')' to close line.");
					}
				}

				// If we have a flag like '--flag=(' we have a long-form
				// flag list opening. Store line for later use in case
				// the parentheses is not closed.
				if (value === "(") {
					// Unclosed '('.
					if (last_open_pr.length) {
						line_count = last_open_pr[0];
						error("Unclosed open parentheses.");
					}

					// Store line of open bracket for later use in error.
					last_open_pr = [line_count];
					mflag = `${hyphens}${flag}`;
				}

				// Add to lookup table if not already.
				let chain = lookup[commandchain];
				if (chain) {
					// Starts with '$(' or '(' and ends with ')'.
					if (/^\$?\(/.test(value) && /\)$/.test(value)) {
						// [TODO] Check for empty command-flag/list.

						// Clean command-flag string.
						if (value.charAt(0) === "$") {
							value = paramparse(value);
							chain.push(`${hyphens}${flag}${setter}${value}`);
						}
						// Options value list starts with '(' and ends with ')'.
						else {
							// Remove wrapping '(' and ')'.
							value = value.replace(/^\(|\)$/g, "");

							// Parse flag option list into individual items.
							let args = argparser(value);

							// If list is empty give error.
							if (!value.replace(/[ \t]/g, "")) {
								warning(`Empty '()' (no flag options).`);
							}

							// Add main flag to list
							chain.push(`${hyphens}${flag}${setter}`);

							// Normalize setter.
							setter = setter.replace("*", "");

							// Add each value with its flag.
							for (let i = 0, l = args.length; i < l; i++) {
								// Cache current loop item.
								let arg = args[i];
								// Add to flags list.
								chain.push(`${hyphens}${flag}${setter}${arg}`);
							}
						}
					}
					// Multi-flags, normal flags (w/ or w/ out setter/value).
					else {
						chain.push(`${hyphens}${flag}${setter}`);
					}
				}

				// Else it's a valid setting so reset vars.
				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "flag_option") {
				// Look ahead to grab setting.
				let { chars_str, indices } = lookahead(i, contents, r_nl);

				// Check if setting syntax is valid give general error.
				if (!r_flag_option.test(chars_str)) {
					// Further breakdown exact syntax error?
					// - setting name check?
					// - value check (if quoted is it properly quoted.)

					// General error.
					error(`Invalid flag option.`);
				}

				// If flag chain exists add flag option.
				let chain = lookup[commandchain];
				if (chain) {
					// [TODO] Parse option before adding to chain flags.

					chain.push(
						// Trim, remove option syntax, and store.
						`${mflag}=${chars_str.replace(
							/^[ \t]*-[ \t]*|[ \t]*$/g,
							""
						)}`
					);
				}

				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "close_parenthesis") {
				if (!mflag) {
					error(`Unmatched closing parentheses.`);
				}

				// Look ahead to grab setting.
				let { chars_str, indices } = lookahead(i, contents, r_nl);

				// Remove all whitespace from string.
				let stripped = chars_str.replace(/[ \t]/g, "");

				// Must pass RegExp pattern.
				if (!r_close_parens.test(chars_str)) {
					// Check for trailing chars.
					error(
						`Illegal character${
							stripped.length - 1 > 1 ? "s" : ""
						} after ')'.`
						// , cline.indexOf("[") + 1
					);
				}

				// Reset flags.
				mflag = null;
				last_open_pr.length = 0;

				// Else it's a valid setting so reset vars.
				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "close_bracket") {
				// Unmatched ']'.
				if (!mcommand) {
					error(`Unmatched closing bracket.`);
				}

				// Look ahead to grab setting.
				let { chars_str, indices } = lookahead(i, contents, r_nl);

				// Remove all whitespace from string.
				let stripped = chars_str.replace(/[ \t]/g, "");

				// Must pass RegExp pattern.
				if (!r_close_br.test(chars_str)) {
					// Check for trailing chars.
					error(
						`Illegal character${
							stripped.length - 1 > 1 ? "s" : ""
						} after ']'.`
						// , cline.indexOf("[") + 1
					);
				}

				// If command chain's flag array is empty give warning.
				let flags = lookup[commandchain];
				if (flags && !flags.length) {
					warning(
						`Empty '[]' (no flags).`,
						undefined,
						last_open_br[0]
					);
				}

				// Reset flags.
				mcommand = null;
				commandchain = "";
				last_open_br.length = 0;

				// Else it's a valid setting so reset vars.
				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "comment") {
				// Reset index to comment ending newline index.
				let la = lookahead(i, contents, r_nl);
				i = la.indices[1] - 1;
			}
		}
	}

	// If flags are still set post loop, a brace remained opened.
	// Unclosed '['.
	if (last_open_br.length) {
		line_count = last_open_br[0];
		error("Unclosed open bracket.");
	}
	// Unclosed '('.
	if (last_open_pr.length) {
		line_count = last_open_pr[0];
		error("Unclosed open parentheses.");
	}

	console.log("");
	console.log(chalk.bold.blue("LOOKUP:"));
	console.log(lookup);
	console.log("");
	console.log(chalk.bold.blue("SETTINGS:"));
	console.log(settings);
	console.log("");
	console.log(chalk.bold.blue("NEWLINES:"));

	for (let i = 0, l = newlines.length; i < l; i++) {
		// Cache current loop item.
		let line = newlines[i];

		console.log(line);
	}
	console.log("");

	exit([]);

	// // Return generated acdef/config file contents.
	// return {
	// 	acdef: header
	// 		.concat(
	// 			merge(commandname, lookup, newlines).sort(function(a, b) {
	// 				return a.localeCompare(b);
	// 			})
	// 		)
	// 		.join("\n")
	// 		.replace(/\s*$/, ""),
	// 	config: config(settings, header)
	// };
};
