"use strict";

// Parser:
// ✓ comments
// 	✓ single line
// 	✖ trailing-ending comments
// ✓ @settings
// ✓ command chains
// 	✓ shortcuts
// ✓ long-form flags
// 	✓ command-flags
// 	✓ flags options list

// ✖ balanced braces - necessary?
// ✖ validate characters for command chains
// ✖ account for line numbers/errors

// // Needed modules.
// const path = require("path");
// const chalk = require("chalk");
// const { exit } = require("./utils.js");

module.exports = (contents, commandname, source) => {
	// Vars - General.
	let line = "";
	let line_count = 0;
	let settings = {};
	// Vars - Multi-flag (outer → --flag=[])
	let ismultiline = false;
	let multiline_start;
	let sublines = [];
	// Vars - Multi-flag (inner → --flag=())
	let ismultilineflag = false;
	let multiline_start_flag;
	let sublines_flag;
	let last_multif_flag;

	// Vars - General.
	// acmap file header.
	let header = [
		`# THIS FILE IS AUTOGENERATED —— DO NOT EDIT FILE DIRECTLY.`,
		`# ${new Date()};${Date.now()}`,
		`# nodecliac definition mapfiles: ~/.nodecliac/defs/\n`
	];
	let newlines = [];
	let lookup = {};

	/**
	 * Build acdef config file contents from extracted settings.
	 *
	 * @param  {object} settings - The settings object.
	 * @return {string} - The config file contents string.
	 */
	let config = settings => {
		// Store lines.
		let lines = [];

		// Loop over settings to build config.
		for (let setting in settings) {
			if (settings.hasOwnProperty(setting)) {
				lines.push(`${setting} = ${settings[setting]}`);
			}
		}

		// Add header to lines and return final lines.
		return header
			.concat(
				lines.sort(function(a, b) {
					return a.localeCompare(b);
				})
			)
			.join("\n")
			.replace(/\s*$/, "");
	};

	/**
	 * Expand shortcuts. For example, command.{cmd1|cmd2} will expand
	 *     to command.cmd1 and command.cmd2.
	 *
	 * @param  {string} commandchain - The commandchain with shortcuts to
	 *     expand.
	 * @return {array} - Array containing the expand lines.
	 */
	let expand_shortcuts = commandchain => {
		let flines = [];

		if (/{.*?}/.test(commandchain)) {
			let shortcuts;

			// Place hold shortcuts.
			commandchain = commandchain.replace(/{.*?}/, function(match) {
				// Remove syntax decorations + whitespace.
				shortcuts = match.replace(/^{|}$/gm, "").split("|");

				for (let i = 0, l = shortcuts.length; i < l; i++) {
					// Cache current loop item.
					let sc = shortcuts[i];

					flines.push(commandchain.replace(/{.*?}/, sc));
				}

				// Remove shortcut from command by returning anonymous placeholder.
				return "--PL";
			});
		}

		// Use function recursion to completely expand all shortcuts.
		let recursion = [];
		if (/{.*?}/.test(flines[0])) {
			for (let i = 0, l = flines.length; i < l; i++) {
				// Cache current loop item.
				let commandchain = flines[i];

				recursion = recursion.concat(
					expand_shortcuts(commandchain, true)
				);
			}
		}
		if (recursion.length) {
			return recursion;
		}

		return flines;
	};

	/**
	 * Create a lookup table to remove duplicate command chains. Duplicate
	 *     chains will have all their respective flag sets combined as well.
	 *
	 * @param  {string} commandchain - The line's command chain.
	 * @param  {string} flags - The line's flag set.
	 * @return {undefined} - Nothing is returned.
	 */
	let dupecheck = (commandchain, flags) => {
		// // Check if command chain contains invalid characters.
		// let r = /[^-._:a-zA-Z0-9\\/]/;
		// if (r.test(commandchain)) {
		// 	// Loop over command chain to highlight invalid character.
		// 	let chars = [];
		// 	let invalid_char_count = 0;
		// 	for (let i = 0, l = commandchain.length; i < l; i++) {
		// 		// Cache current loop item.
		// 		let char = commandchain[i];

		// 		// If an invalid character highlight.
		// 		if (r.test(char)) {
		// 			chars.push(chalk.bold.red(char));
		// 			invalid_char_count++;
		// 		} else {
		// 			chars.push(char);
		// 		}
		// 	}

		// 	// Plural output character string.
		// 	let char_string = `character${invalid_char_count > 1 ? "s" : ""}`;

		// 	// Invalid escaped command-flag found.
		// 	exit([
		// 		`${chalk.bold(
		// 			"Invalid:"
		// 		)} ${char_string} in command: ${chars.join("")}`,
		// 		`Remove invalid ${char_string} to successfully parse acmap file.`
		// 	]);
		// }
		// // Command must start with letters.
		// if (!/^\w/.test(commandchain)) {
		// 	exit([
		// 		`${chalk.bold(
		// 			"Invalid:"
		// 		)} command '${commandchain}' must start with a letter.`,
		// 		`Fix issue to successfully parse acmap file.`
		// 	]);
		// }

		// Normalize command chain. Replace unescaped '/' with '.' dots.
		commandchain = commandchain.replace(/([^\\]|^)\//g, "$1.");

		// Note: Create needed parent commandchain(s). For example, if the
		// current commandchain is 'a.b.c' we create the chains: 'a.b' and
		// 'a' if they do not exist. Kind of like 'mkdir -p'.
		// Parse command chain for individual commands.
		let cparts = [];
		let command = "";
		let command_string = "";
		let command_count = 0;
		for (let i = 0, l = commandchain.length; i < l; i++) {
			// Cache current loop characters.
			let char = commandchain.charAt(i);
			let pchar = commandchain.charAt(i - 1);
			let nchar = commandchain.charAt(i + 1);

			// If a dot or slash and it's not escaped.
			if (/(\.|\/)/.test(char) && pchar !== "\\") {
				// Push current command to parts array.
				cparts.push(command);

				// Track command path.
				command_string += command_count ? `.${command}` : command;
				// Add command path to lookup.
				if (!lookup[command_string]) {
					lookup[command_string] = [];
				}

				// Clear current command.
				command = "";
				command_count++;
				continue;
			} else if (char === "\\" && /(\.|\/)/.test(nchar)) {
				// Add separator to current command since it's used as
				// an escape sequence.
				command += `\\${nchar}`;
				i++;
				continue;
			}

			// Append current char to current command string.
			command += char;
		}
		// // Add remaining command if string is not empty.
		// if (command) { cparts.push(command); }

		// Store in lookup table.
		if (!lookup[commandchain]) {
			lookup[commandchain] = [flags];
		} else {
			lookup[commandchain].push(flags);
		}
	};

	/**
	 * Parse string by spaces. Takes into account quotes strings with spaces.
	 *     Making sure to ignore those spaces. Also respects escaped characters.
	 *     Adapted from argsplit module.
	 *
	 * @param  {string} input - The string input to parse.
	 * @return {array} - Array containing the parsed items.
	 *
	 * @resource [https://github.com/evanlucas/argsplit]
	 * @resource - Other CLI input parsers:
	 *     [https://github.com/elgs/splitargs]
	 *     [https://github.com/vladimir-tikhonov/string-to-argv#readme]
	 *     [https://github.com/astur/arrgv]
	 *     [https://github.com/mccormicka/string-argv]
	 *     [https://github.com/adarqui/argparser-js]
	 */
	let argparser = input => {
		// Vars.
		let current = "";
		let quote_char = "";
		let args = [];

		// Return empty array when input is empty.
		if (!input || !input.length) {
			return args;
		}

		// Loop over every input char.
		for (let i = 0, l = input.length; i < l; i++) {
			// Cache current/previous/next chars.
			let c = input.charAt(i);
			let p = input.charAt(i - 1);
			// let n = input.charAt(i + 1);

			// Reset prev word for 1st char as bash gets the last char.
			if (i === 0) {
				p = "";
			}
			// else if (i === l - 1) {
			// 	// Reset next word for last char as bash gets the first char.
			// 	n = "";
			// }

			// If char is a space.
			if (c === " " && p !== "\\") {
				if (quote_char.length !== 0) {
					current += c;
				} else {
					if (current !== "") {
						args.push(current);
						current = "";
					}
				}
				// Non space chars.
			} else if ((c === '"' || c === "'") && p !== "\\") {
				if (quote_char !== "") {
					if (quote_char === c) {
						current += c;
						args.push(current);
						quote_char = "";
						current = "";
					} else {
						current += c;
						quote_char = c;
					}
				} else {
					current += c;
					quote_char = c;
				}
			} else {
				current += c;
			}
		}

		// Add the remaining word.
		if (current !== "") {
			args.push(current);
		}

		return args;
	};

	/**
	 * Parse string command flag ($("")) arguments. This is done to basically
	 *     to make command-flags uniform. For example, user can space out
	 *     arguments. This will ensure that all space around arguments is
	 *     effectively removed.
	 *
	 * @param  {string} input - The string command-flag to parse.
	 * @return {string} - The cleaned command-flag string.
	 */
	let paramparse = input => {
		// Parse command string to get individual arguments. Things to note:
		// each argument is to be encapsulated with strings. User can decide
		// which to use, either single or double. As long as their contents
		// are properly escaped.
		let args = [];
		let argument = "";
		let state = "closed";
		let quote_type = "";
		// let args_count = 0;

		// Return empty string when input is empty.
		if (!input || !input.length) {
			return '$("")';
		}

		// Remove '$()' syntax.
		input = input.replace(/^\$\(|\)$/g, "").trim();

		// Command flag syntax:
		// $("COMMAND-STRING" [, [<ARG1>, <ARGN> [, "<DELIMITER>"]]])

		// Loop over every input char.
		for (let i = 0, l = input.length; i < l; i++) {
			// Cache current/previous/next chars.
			let char = input.charAt(i);
			let pchar = input.charAt(i - 1);
			let nchar = input.charAt(i + 1);

			// If char is an unescaped quote.
			if (/["']/.test(char) && pchar !== "\\" && state === "closed") {
				// Check if the previous character is a dollar sign. This
				// means the command should run as a command.
				if (pchar && pchar === "$") {
					argument += "$";
				}
				// Set state to open.
				state = "open";
				// Set quote type.
				quote_type = char;
				// Store the character.
				argument += char;
			} else if (
				// If char is an unescaped quote + status is open...reset.
				/["']/.test(char) &&
				pchar !== "\\" &&
				state === "open" &&
				quote_type === char
			) {
				// Set state to close.
				state = "closed";
				// Reset quote type.
				quote_type = "";
				// Store the character.
				argument += char;
			} else if (char === "\\") {
				// Handle escaped characters.
				if (nchar) {
					// Store the character.
					argument += `${char}${nchar}`;
					i++;
				} else {
					// Store the character.
					argument += char;
				}
			} else if (!/["']/.test(char)) {
				// For anything that is not a quote char.

				// If we hit a comma and the state is closed. We store the
				// current argument and reset everything.
				if (state === "closed" && char === ",") {
					args.push(argument);
					// args_count++;
					argument = "";
				} else if (state === "open") {
					// Store the character.
					argument += char;
				}
			}
		}
		// Add remaining argument if string is not empty.
		if (argument) {
			args.push(argument);
			// args_count++;
		}

		// Return cleaned arguments string.
		return `$(${args.join(",")})`;
	};

	/**
	 * Make the provided array unique.
	 *
	 * @param  {array} array - The array to clean.
	 * @param  {boolean} flag_sort - Flag indicating whether the array needs to be sorted.
	 * @return {array} - The worked on array.
	 *
	 * @resource [http://stackoverflow.com/questions/1960473/unique-values-in-an-array/39272981#39272981]
	 * @ersource [http://stackoverflow.com/questions/1063007/how-to-sort-an-array-of-integers-correctly/21595293#21595293]
	 */
	let make_unique = function(array, flag_sort) {
		// Make array unique.
		array = array.filter(function(x, i, a_) {
			return a_.indexOf(x) === i;
		});

		// Sort the array if flag set.
		// **Note: does not sort numbers.
		if (flag_sort) {
			if (flag_sort === "alpha") {
				// [https://stackoverflow.com/a/16481400]
				array = array.sort(function(a, b) {
					return a.localeCompare(b);
				});
			} else if (flag_sort === "number") {
				array.sort(function(a, b) {
					return a - b;
				});
			}
		}

		// Return the array.
		return array;
	};

	/**
	 * Fill-in placeholded long-form flags with collapsed single line
	 *     containing the formated flags.
	 *
	 * @param  {string} contents - The line with possible placeholders.
	 * @return {string} - The filled line with collapsed and formatted flags.
	 */
	let formatflags = flags => {
		// Return if provided array is empty.
		if (!flags.length) {
			return [];
		}

		// Format flags:
		let lists = {
			type1: [],
			type2: [],
			type3: {
				list: [],
				lookup: {}
			}
		};
		let t2list = lists.type2;
		let t3list = lists.type3.list;
		// let t3lkup = lists.type3.lookup;

		// Loop over flags and format.
		for (let i = 0, l = flags.length; i < l; i++) {
			// Cache current loop item.
			let flag = flags[i].trim();

			// Flag forms:
			// --flag             → type 1
			// --flag=            → type 2
			// --flag=*           → type 2
			// --flag=value       → type 3

			if (!flag.includes("=")) {
				// Flag forms:
				// --flag

				// Add flag if not already in list.
				if (!-~lists.type1.indexOf(flag)) {
					lists.type1.push(flag);
				}
			} else {
				// Flag forms:
				// --flag=, --flag=*, --flag=value

				// If in form → --flag=/--flag=*, add to list if not already.
				if (
					/^-{1,2}[a-z][-.a-z0-9]*=\*?$/i.test(flag) &&
					!-~t2list.indexOf(flag)
				) {
					if (flag.endsWith("*")) {
						// If non-asterisk form has already been added, remove
						// it from the list.
						let fflag = flag.slice(0, -1);
						if (t2list.includes(fflag)) {
							// Remove it from the list.
							t2list.splice(t2list.indexOf(fflag), 1);
						}
					} else {
						// If asterisk form has been already added don't add
						// non-asterisk flag.
						if (t2list.includes(`${flag}*`)) {
							continue;
						}
					}

					t2list.push(flag);
				} else {
					// Flag forms:
					// --flag=value

					// Split into flag (key) and value.
					let eq_index = flag.indexOf("=");
					let key = flag.substring(0, eq_index);
					let value = flag.substring(eq_index + 1);

					// Cleanup flag if it's a command-flag.
					if (/^\$\(.*?\)$/.test(value)) {
						flag = `${key}=${paramparse(value)}`;
					}

					let fkey = `${key}=`;
					// Since this key has options make sure to also add the key
					// to the type 2 flags as well if not explicitly provided.
					if (
						!-~t2list.indexOf(fkey) &&
						!-~t2list.indexOf(`${fkey}*`)
					) {
						t2list.push(fkey);
					}

					// Add to type3 list.
					t3list.push(flag);

					//////////////////////////////////////////*
					// // If the flag has a value as an option. Join multiple
					// // flag options into a single-mega option.
					//
					// // Split into flag (key) and value.
					// let eq_index = flag.indexOf("=");
					// let key = flag.substring(0, eq_index);
					// let value = flag.substring(eq_index + 1);
					//
					// // Add flag if not already in list.
					// if (!t3lkup[key]) {
					// 	// Store value.
					// 	t3lkup[key] = [value];
					// } else {
					// 	// Else, flag is already in list. Just add the value.
					// 	t3lkup[key].push(value);
					// }
					//////////////////////////////////////////*
				}
			}
		}

		//////////////////////////////////////////*
		// // Combine all flags into a single line.
		// // Prep type3 flag types.
		// let obj = lists.type3.lookup;
		// for (let key in obj) {
		// 	if (obj.hasOwnProperty(key)) {
		// 		let fkey = `${key}=`;
		// 		// Since this key has options make sure to also add the key
		// 		// to the type 2 flags as well if not explicitly provided.
		// 		if (
		// 			!-~t2list.indexOf(fkey) &&
		// 			!-~t2list.indexOf(`${fkey}*`)
		// 		) {
		// 			t2list.push(fkey);
		// 		}
		//
		// 		let value = obj[key].join(" ");
		// 		// Add to type3 list.
		// 		t3list.push(`${key}=(${value})`);
		// 	}
		// }
		//////////////////////////////////////////*

		return lists.type1.concat(lists.type2, lists.type3.list);
	};

	let prepline = (line, indices, multiflags) => {
		// Remove starting/trailing whitespace?
		line = line.trim();

		// Ignore comments/empty lines.
		if (line.charAt(0) === "#" || !line) return;

		// Check if settings line.
		if (/^@/.test(line)) {
			// Extract setting name/value.
			let [, setting, value] = line.match(
				/(@[-_:a-zA-Z0-9]{1,})\s*=\s*(.{1,})?$/
			);
			// Store setting/value in settings object.
			settings[setting] = value;

			// Return to not store line.
			return;
		}

		// Extract command chain and flags.
		let [, commandchain = "", , flaglist = ""] = line.match(
			/^(.*?)(?:(\s*=?\s*))((-|\[)[\s\S]*?)?$/
		);

		// Work flags...
		let flags = [];
		if (multiflags.length) {
			for (let i = 0, l = multiflags.length; i < l; i++) {
				// Cache current loop item.
				let set = multiflags[i];
				let stype = set.pop();
				// let region = set.pop();

				if (stype === 1) {
					// If the last item is ')' then we remove it.
					// If not then then we edit the last item to remove
					// the ')'
					let last_item = (set[set.length - 1] || "").trim();
					if (last_item === ")") {
						set.pop();
					} else {
						set[set.length - 1] = last_item.replace(/\)/, "");
					}

					// Get the flag key.
					let fkey = set[0].trim().replace(/\(\s*$/, "");
					// Check if it's a multiflag.
					if (fkey.endsWith("=*")) {
						fkey = fkey.replace(/=\*/, "=");
					}
					flags.push(fkey);

					for (let j = 1, ll = set.length; j < ll; j++) {
						// Cache current loop item.
						let value = set[j].trim().replace(/^-\s*/, "");

						// if (value.startsWith("$")) {
						// 	value = paramparse(value);
						// }

						flags.push(`${fkey}${value}`);
					}
				} else if (stype === 2) {
					let [, fkey, setter, opts] = set[0]
						.trim()
						.match(/^(-{1,2}.*?)(=\*?)\((.*?)\)$/);
					flags.push(`${fkey}${setter}`);

					// Get individual value options.
					let options = argparser(opts);

					for (let j = 0, ll = options.length; j < ll; j++) {
						// Cache current loop item.
						let option = options[j];
						flags.push(`${fkey}=${option}`);
					}
				} else if (stype === 3) {
					flags.push(set[0].trim());
				}
			}
		}
		// One-liner flags list.
		else {
			// If a list exist then turn into an array.
			if (flaglist) {
				// Parse on unescaped '|' characters:
				// [https://stackoverflow.com/a/25895905]
				// [https://stackoverflow.com/a/12281034]
				flags = flaglist.split(/(?<=[^\\]|^|$)\|/);
			}
		}

		// Format flags list.
		flags = formatflags(flags);

		// If dealing with command flags: run paramparse
		// If dealing with long-form flags: run unexpand_mf_options

		// Work command chain...

		// Expand any shortcuts.
		if (/{.*?}/.test(commandchain)) {
			let chains = expand_shortcuts(commandchain);
			for (let i = 0, l = chains.length; i < l; i++) {
				// Dupe check line.
				dupecheck(chains[i], flags);
			}
		} else {
			// No shortcuts, just dupe check.
			dupecheck(commandchain, flags);
		}
	};

	// Main loop. Loops over each character in acmap.
	for (let i = 0, l = contents.length; i < l; i++) {
		// Cache current/previous/next chars.
		let char = contents.charAt(i);
		// let pchar = contents.charAt(i - 1);
		let nchar = contents.charAt(i + 1);

		// Check for \r\n newline sequence OR check for regular \n newline char.
		if ((char === "\r" && nchar === "\n") || char === "\n") {
			line_count++;

			// Append normalized newline char.
			line += "\n";

			// Multi-flag checks:
			// If line ends with '[' (disregarding space)...
			if (/\[\s*$/.test(line)) {
				ismultiline = true;
				// Keep track of where the multiflag line starts.
				multiline_start = line_count;
			}
			// If line ends with ']' (disregarding space)...
			else if (/\]\s*$/.test(line)) {
				ismultiline = false;
				// Push last line to sublines.
				sublines.push(line);
			}

			if (ismultiline || ismultilineflag) {
				// Remove starting/trailing whitespace?
				let tline = line.trim();

				// Ignore comments/empty lines.
				if (tline && tline.charAt(0) !== "#") {
					// Add line to sublines.
					sublines.push(line);

					// Multi-flag checks:
					// If line ends with '(' (disregarding space)...
					if (/\(\s*$/.test(line)) {
						last_multif_flag = [line];
						if (!sublines_flag) {
							sublines_flag = [];
						}
						sublines_flag.push(last_multif_flag);

						ismultilineflag = true;
						// Keep track of where the multiflag line starts.
						multiline_start_flag = line_count;
					}
					// If line ends with ')' (disregarding space)...
					else if (
						/\)\s*$/.test(line) &&
						// // Cannot be a command-flag.
						!/^\s*-\s*\$\(.*\)\s*$/.test(line) &&
						ismultilineflag
					) {
						ismultilineflag = false;
						// Push last line to sublines.
						last_multif_flag.push(
							line,
							[multiline_start_flag, line_count],
							1
						);
						// Reset flag line number.
						multiline_start_flag = 0;
					}
					// Flag option.
					else if (/^\s*-\s/.test(tline)) {
						// last_multif_flag.push(line.replace(/^\s*-\s*/, ""));
						last_multif_flag.push(line);
					}
					// Flag form: --flag=(val1 val2)
					else if (/^-{1,2}.*?=\*?\(.*?\)$/.test(tline)) {
						last_multif_flag = [line];
						if (!sublines_flag) {
							sublines_flag = [];
						}

						// Push last line to sublines.
						last_multif_flag.push([line_count], 2);

						sublines_flag.push(last_multif_flag);

						// ismultilineflag = true;
						// Keep track of where the multiflag line starts.
						multiline_start_flag = line_count;
					} else if (ismultiline && /^-/.test(tline)) {
						last_multif_flag = [line];
						if (!sublines_flag) {
							sublines_flag = [];
						}

						// Push last line to sublines.
						last_multif_flag.push([line_count], 3);

						sublines_flag.push(last_multif_flag);

						// ismultilineflag = true;
						// Keep track of where the multiflag line starts.
						multiline_start_flag = line_count;
					}
				}

				// Clear line.
				line = "";
			}

			// Prep line if not a multi-flag line.
			if (!ismultiline) {
				let indices = [multiline_start || line_count];

				if (sublines.length) {
					line = sublines.join("");
					indices.push(line_count);
					sublines.length = 0;
				}

				// Split line into commandchain/flags.
				prepline(line, indices, sublines_flag || []);

				// Reset line.
				line = "";
				multiline_start = null;
				last_multif_flag = null;
				sublines_flag = null;
				multiline_start_flag = 0;
			}

			// Increment index to account for the following "\n" char.
			if (char === "\r") i++;
		}
		// All other characters.
		else {
			line += char;
		}
	}

	// Create final contents by combining duplicate command chains with
	// all their flag sets.
	let has_root = false;
	let r = new RegExp(`^(${commandname}|[-_a-zA-Z0-9]+)`, "gm");
	for (let commandchain in lookup) {
		if (commandchain && lookup.hasOwnProperty(commandchain)) {
			// Get flags array.
			let flags = lookup[commandchain];
			let fcount = flags.length;

			if (fcount) {
				// Join (flatten) all flag sets:
				// [https://www.jstips.co/en/javascript/flattening-multidimensional-arrays-in-javascript/]
				flags = flags.reduce(function(prev, curr) {
					return prev.concat(curr);
				});

				// Dedupe and sort flags if multiple sets exist.
				flags = make_unique(flags, "alpha").join("|");
			} else {
				flags = "--";
			}

			// Remove the main command from the command chain. However,
			// when the command name is not the main command in (i.e.
			// when running on a test file) just remove the first command
			// name in the chain.
			let row = `${commandchain.replace(r, "")} ${flags}`;

			// Remove multiple ' --' command chains. This will happen for
			// test files with multiple main commands.
			if (row === " --" && !has_root) {
				has_root = true;
			} else if (row === " --" && has_root) {
				continue;
			}

			newlines.push(row);
		}
	}

	// Return generated acdef/config file contents.
	return {
		acdef: header
			.concat(
				newlines.sort(function(a, b) {
					return a.localeCompare(b);
				})
			)
			.join("\n")
			.replace(/\s*$/, ""),
		config: config(settings)
	};
};
