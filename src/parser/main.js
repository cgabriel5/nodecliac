"use strict";

// Parser:
// ✓ comments
// 	✓ single line
// 	✖ trailing-ending comments
// ✓ @settings
// ✓ command chains
// 	✓ shortcuts
// ✓ long-form flags
// 	✓ command-flags
// 	✓ flags options list

// ✖ balanced braces - necessary?
// ✖ validate characters for command chains
// ✖ account for line numbers/errors

// Needed modules.
// const path = require("path");
const chalk = require("chalk");
const { exit } = require("../utils.js");

// Require parser functions.
const config = require("./config.js");
const shortcuts = require("./shortcuts.js");
const dedupe = require("./dedupe.js");
const argparser = require("./argparser.js");
const formatflags = require("./formatflags.js");
const merge = require("./merge.js");

module.exports = (contents, commandname, source) => {
	// Vars - General.
	let line = "";
	let line_count = 0;
	let indentation = "";
	let lookup = {};
	let settings = {};
	let newlines = [];

	let commandchain;
	let mflag;
	let mcommand;
	let line_type;

	let last_open_br = [];
	let last_open_pr = [];

	// acmap file header.
	let header = [
		`# THIS FILE IS AUTOGENERATED —— DO NOT EDIT FILE DIRECTLY.`,
		`# ${new Date()};${Date.now()}`,
		`# nodecliac definition mapfiles: ~/.nodecliac/defs/\n`
	];

	// Check if provided char is a space.
	let isspace = char => {
		return /[ \t]/.test(char);
	};

	/**
	 * Does 1 of two things. Either looks ahead and captures all characters
	 *     until provided RegExp fails or captures all characters until
	 *     RegExp passed. The latter method may be used to capture all
	 *     characters for a line, for example.
	 *
	 * @param  {number} index - The index offset to start capturing/testing.
	 * @param  {string} input - The string to test.
	 * @param  {regexp} r - The RegExp object to test characters against.
	 * @param  {number} rcount - Optional amount of characters to capture.
	 * @return {object} - Object containing passing/failing chars and
	 *     starting/ending capture indices.
	 *
	 * Examples:
	 * - Return all chars until RegExp is matched. Example will return all
	 *     characters until newline char is found.
	 * lookahead(2, "Some text.", new RegExp("\\r?\\n"));
	 * - Return n chars (in this case 1) that match RegExp.
	 * lookahead(2, "Some text.", new RegExp("[a-zA-Z]"), 1);
	 */
	let lookahead = (index, input, r, rcount) => {
		let chars = []; // RegExp passing chars.
		let chars_str = ""; // chars in string form.
		let xchars = []; // RegExp excluded chars.
		let xchars_str = ""; // xchars in string form.
		let sindex, eindex;

		// Check if return character count was provided.
		let rexists = rcount !== undefined;

		// Start looping string at provided index offset.
		for (let i = index, l = input.length; i < l; i++) {
			// Cache current loop item.
			let char = input[i];

			if (rexists) {
				// Once counter hits 0 all needed characters were captured.
				if (!rcount) {
					break;
				}

				// Test current character against provided RegExp.
				if (r.test(char)) {
					// Set starting match index if not already set.
					if (!sindex) {
						sindex = i;
					}

					// If character passes RegExp then add to passed array.
					chars.push(char);
					// Append to string.
					chars_str += char;

					// Decrease counter.
					if (rexists) {
						rcount--;

						// Set ending match index.
						eindex = i;
					}
				} else {
					// Set starting match index if not already set.
					if (!sindex) {
						sindex = i;
					}

					// Set ending match index.
					eindex = i;

					// Store failing characters.
					xchars.push(char);
					// Append to string.
					xchars_str += char;

					// Exit loop once RegExp fails.
					break;
				}
			} else {
				// This will capture all chars until RegExp matches.

				// Test current character against provided RegExp.
				if (!r.test(char)) {
					// Set starting match index if not already set.
					if (!sindex) {
						sindex = i;
					}

					// If character fails RegExp add to passed array.
					chars.push(char);
					// Append to string.
					chars_str += char;
				} else {
					// Set ending match index.
					eindex = i;

					// Store passing match.
					xchars.push(char);
					// Append to string.
					xchars_str += char;

					// Once RegExp passes we break.
					break;
				}
			}
		}

		// If glob until method was used and the contents does not contain
		// the ending character then we set the end index to that of the
		// input's length.
		if (!eindex && !rexists) {
			eindex = input.length;
		}

		return {
			chars,
			xchars,
			indices: [sindex, eindex],
			chars_str,
			xchars_str
		};
	};

	// The index, source input, regexp, return character count.
	let error = (message, index) => {
		exit([
			`[${chalk.bold.red("error")}] ${message} [line ${line_count + 1}${
				index !== undefined ? `:${index}` : ""
			}]`
		]);
	};

	// The index, source input, regexp, return character count.
	let warning = (message, index) => {
		exit(
			[
				`[${chalk.bold.yellow(
					"warning"
				)}] ${message} [line ${line_count + 1}${
					index !== undefined ? `:${index}` : ""
				}]`
			],
			false
		);
	};

	// Main loop. Loops over each character in acmap.
	for (let i = 0, l = contents.length; i < l; i++) {
		// Cache current/previous/next chars.
		let char = contents.charAt(i);
		let pchar = contents.charAt(i - 1);
		let nchar = contents.charAt(i + 1);

		// Check if \r?\n newline sequence.
		if ((char === "\r" && nchar === "\n") || char === "\n") {
			// Increment line counter.
			line_count++;

			// Reset vars.
			line = "";
			line_type = null;
			indentation = "";

			continue;
		}

		// If a line type has not been defined yet.
		if (!line_type) {
			// If the current character is a space then continue.
			if (isspace(char)) {
				indentation += char;
				continue;
			}

			// If not a space character, look for an allowed character.
			// Lines can start with following chars/char sets.
			// @      → setting
			// #      → comment
			// a-zA-Z → command chain
			//     -      → flag
			//     '- '   → flag option (ignore quotes)
			//     )      → closing flag set
			//     ]      → closing long-flag form
			// -------------------------------------------------------------
			// Special flag characters to look out for:
			// $(, "", ''

			// Char must be an allowed starting char.
			if (!/[-@a-z\)\]#]/i.test(char)) {
				error(
					`${chalk.bold(
						"Syntax"
					)}: Invalid start-of-line character '${char}'.`,
					indentation.length
				);
			}

			// Set line start type.
			if (char === "@") {
				line_type = "setting";
			} else if (char === "#") {
				line_type = "comment";
			} else if (/[a-zA-Z]/.test(char)) {
				line_type = "command";
			} else if (char === "]") {
				line_type = "close_bracket";
			} else if (char === "-") {
				// If flag is set we are getting flag options.
				line_type = mflag
					? // Option must my listed with a hyphen.
					  // /\s/.test(nchar)
					  "flag_option"
					: "flag_set";
			} else if (char === ")") {
				line_type = "close_parenthesis";
			}

			// line += char;
		}

		if (line_type) {
			if (line_type === "setting") {
				// Look ahead to grab setting line.
				let { indices, chars_str } = lookahead(
					i,
					contents,
					new RegExp(`(\\r?\\n)`)
				);

				// Checks:
				// - Empty setting.
				// - Invalid characters.
				// - Duplicate settings.
				// - Dangling setting symbol.
				// - Improperly quoted value.

				// Setting syntax:
				let r = /^(@[a-zA-Z][_a-zA-Z]*)[ \t]*(=[ \t]*(.*?))?$/;

				// Check for dandling setting symbol.
				if (chars_str === "@") {
					error("Dangling '@' setting symbol.", indentation.length);
				}
				// Breakdown setting (setting name/value).
				let matches = chars_str.match(r);
				// No matches means setting name contains invalid characters.
				if (!matches) {
					// [TODO] Do better job in pinpointing invalid characters.
					error(
						// `Invalid setting '${chalk.bold(chars_str.replace(/([^@a-zA-Z])/g, `${chalk.bold.red("$1")}`))}'.`
						`Invalid setting name '${chalk.bold(chars_str)}'.`,
						indentation.length
					);
				}
				// Check that value if quoted is quoted properly.
				let name = matches[1];
				let value = matches[3];
				if (value) {
					let vfchar = value.charAt(0);
					var vlchar = value.charAt(value.length - 1);
					// Check that the last char is a matching quote.
					if (/"|'/.test(vfchar) && vfchar !== vlchar) {
						error(`Improperly quoted setting value.`);
					}
					// Check that the last char is a matching quote.
					else if (/"|'/.test(vlchar) && vlchar !== vfchar) {
						error(`Improperly quoted setting value.`);
					}
				} else {
					error(`Valueless setting '${chalk.bold(matches[0])}'.`);
				}
				// Check if setting syntax is valid or give general error.
				if (!r.test(chars_str)) {
					error(`Invalid setting.`, indentation.length);
				}

				// Else, checks passed so reset vars. Reset index to continue
				// loop at newline character on next iteration.
				i = indices[1] - 1;

				// Store line.
				newlines.push((line += chars_str));

				// If the setting already exists give an override warning.
				if (settings[name]) {
					warning(
						`Duplicate '${chalk.bold(name)}' setting.`,
						indentation.length
					);
				}

				// Store setting/value in settings object.
				settings[name] = value;
			} else if (line_type === "command") {
				// There must not be any whitespace before command.
				if (indentation.length) {
					error(`Command cannot be preceded by white space.`, 0);
				}

				// Look ahead to grab command chain.
				let { chars_str, indices } = lookahead(
					i,
					contents,
					new RegExp(`[-_.:a-zA-Z0-9\\\\\/{}\|]`),
					Infinity
				);

				// Reset index to be at the end of the line.
				i = indices[1] - 1;

				// Next look for command setter (' = ' → ignore quotes).
				line_type = "command_setter";

				// Store chars.
				line += chars_str;

				// Store command chain.
				if (!lookup[line]) {
					lookup[line] = [];
				}
				commandchain = line;
			} else if (line_type === "command_setter") {
				// Look ahead to grab command chain.
				let { chars_str, indices } = lookahead(
					i,
					contents,
					new RegExp(`(\\r?\\n)`)
				);

				// Checks:
				// - Check for invalid characters.
				// - Highlight multiple '=' and '[' characters?
				// - Check for possible invalid characters.

				// RegExp pattern.
				let r = /^[ \t]*=[ \t]*\[/;

				// Current line before char string.
				let cline = `${indentation}${line}`;

				// Must pass RegExp pattern.
				if (!r.test(chars_str)) {
					// [TODO] Check for missing '[' character?

					// Give general error.
					error(
						`Expected ' = [' but saw '${chars_str}' instead.`,
						cline.length
					);
				}

				// Store chars.
				line += chars_str;

				// Look ahead to grab '[' index.
				let la = lookahead(0, chars_str, new RegExp(`\\[`));

				// Reset index to be at the end of the line.
				i = i + la.indices[1] - 1;

				// Next look for command open bracket. ('[' → ignore quotes).
				line_type = "command_open_bracket";
			} else if (line_type === "command_open_bracket") {
				// Unclosed '['.
				if (last_open_br.length) {
					line_count = last_open_br[0];
					error("Unclosed open bracket.");
				}

				// Look ahead to grab command chain.
				let { chars_str, indices } = lookahead(
					i,
					contents,
					new RegExp(`(\\r?\\n)`)
				);

				let r = /^\[\]?$/;
				let stripped = chars_str.replace(/[ \t]/g, "");

				// Current line before char string.
				let cline = `${indentation}${line}`;

				// Must pass RegExp pattern.
				if (!r.test(stripped)) {
					// [TODO] Further breakdown error:
					// We can only have 3 situations:
					// 1 - There are no more characters (excluding spaces).
					// 2 - There is a closing bracket ']'.
					// 3 - There are other chars unallowed chars.
					// 		- Trailing in-line comments?

					// General error.
					error(
						`Expected '[' or '[]' but saw '${chars_str}' instead.`,
						cline.indexOf("[") + 1
					);
				}

				// If bracket is unclosed then set flag.
				if (stripped === "[") {
					// Store line of open bracket for later use in error.
					last_open_br = [line_count];
					mcommand = true;
				}

				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "flag_set") {
				// Look ahead to grab setting.
				let { chars_str, indices } = lookahead(
					i,
					contents,
					new RegExp(`(\\r?\\n)`)
				);

				// Setting syntax:
				let r = /^-{1,2}([a-zA-Z][-_:a-zA-Z0-9]*)[ \t]*(=\*?[ \t]*(\(|\(\))?)?$/;

				// Check if setting syntax is valid give general error.
				if (!r.test(chars_str)) {
					// Further breakdown exact syntax error?
					// - setting name check?
					// - value check (if quoted is it properly quoted.)

					// General error.
					error(`Invalid flag.`);
				}

				// Add to lookup table if not already.
				let chain = lookup[commandchain];
				if (chain) {
					chain.push(chars_str.replace(/[\(\)]/g, ""));
				}

				if (chars_str.includes("(") && !chars_str.includes(")")) {
					// Unclosed '('.
					if (last_open_pr.length) {
						line_count = last_open_pr[0];
						error("Unclosed open parentheses.");
					}

					// Store line of open bracket for later use in error.
					last_open_pr = [line_count];
					mflag = chars_str.replace(/[\=\*\(]/g, "");
				}

				// Else it's a valid setting so reset vars.
				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "flag_option") {
				// Look ahead to grab setting.
				let { chars_str, indices } = lookahead(
					i,
					contents,
					new RegExp(`(\\r?\\n)`)
				);

				// Flag option syntax:
				let r = /^[ \t]*-[ \t]+(.{2,})$/;

				// Check if setting syntax is valid give general error.
				if (!r.test(chars_str)) {
					// Further breakdown exact syntax error?
					// - setting name check?
					// - value check (if quoted is it properly quoted.)

					// General error.
					error(`Invalid flag option.`);
				}

				let chain = lookup[commandchain];
				if (chain) {
					chain.push(
						// Trim, remove option syntax, and store.
						`${mflag}=${chars_str.replace(
							/^[ \t]*-[ \t]*|[ \t]*$/g,
							""
						)}`
					);
				}

				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "close_parenthesis") {
				if (!mflag) {
					error(`Unmatched closing parentheses.`);
				}

				// Look ahead to grab setting.
				let { chars_str, indices } = lookahead(
					i,
					contents,
					new RegExp(`(\\r?\\n)`)
				);

				// Flag option syntax:
				let r = /^[ \t]*\)[ \t]*$/;

				// Check if setting syntax is valid give general error.
				if (!r.test(chars_str)) {
					// Further breakdown exact syntax error?
					// - setting name check?
					// - value check (if quoted is it properly quoted.)

					// General error.
					error(`Invalid closing parentheses.`);
				}

				// Reset flags.
				mflag = null;
				last_open_pr.length = 0;

				// Else it's a valid setting so reset vars.
				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "close_bracket") {
				// Unmatched ']'.
				if (!mcommand) {
					error(`Unmatched closing bracket.`);
				}

				// Look ahead to grab setting.
				let { chars_str, indices } = lookahead(
					i,
					contents,
					new RegExp(`(\\r?\\n)`)
				);

				// Flag option syntax:
				let r = /^[ \t]*\][ \t]*$/;

				// Check if setting syntax is valid give general error.
				if (!r.test(chars_str)) {
					// [TODO] Further breakdown exact syntax error?
					// Check for remaining chars.
					// Trailing in-line comments?

					// General error.
					error(`Invalid closing bracket.`);
				}

				// Reset flags.
				mcommand = null;
				last_open_br.length = 0;

				// Else it's a valid setting so reset vars.
				// Reset index to be at the end of the line.
				i = indices[1] - 1;
			} else if (line_type === "comment") {
				// Reset index to comment ending newline index.
				let la = lookahead(i, contents, new RegExp(`(\\r?\\n)`));
				i = la.indices[1] - 1;
			}
		}
	}

	// If flags are set then unclosed braces remained.
	// Unclosed '['.
	if (last_open_br.length) {
		line_count = last_open_br[0];
		error("Unclosed open bracket.");
	}
	// Unclosed '('.
	if (last_open_pr.length) {
		line_count = last_open_pr[0];
		error("Unclosed open parentheses.");
	}

	console.log("");
	console.log(chalk.bold.blue("LOOKUP:"));
	console.log(lookup);
	console.log("");
	console.log(chalk.bold.blue("SETTINGS:"));
	console.log(settings);
	console.log("");
	console.log(chalk.bold.blue("NEWLINES:"));

	for (let i = 0, l = newlines.length; i < l; i++) {
		// Cache current loop item.
		let line = newlines[i];

		console.log(line);
	}
	console.log("");

	exit([]);

	// // Return generated acdef/config file contents.
	// return {
	// 	acdef: header
	// 		.concat(
	// 			merge(commandname, lookup, newlines).sort(function(a, b) {
	// 				return a.localeCompare(b);
	// 			})
	// 		)
	// 		.join("\n")
	// 		.replace(/\s*$/, ""),
	// 	config: config(settings, header)
	// };
};
