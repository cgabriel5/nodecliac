"use strict";

// Needed modules.
const path = require("path");
const chalk = require("chalk");
const { exit } = require("../utils.js");

// Require parser functions.
// const merge = require("./merge.js");
// const config = require("./config.js");
// const dedupe = require("./dedupe.js");
// const shortcuts = require("./shortcuts.js");
// const formatflags = require("./formatflags.js");
// Get parsers.
const psetting = require("./p.setting.js");
const pcommand = require("./p.command.js");
const pbrace = require("./p.close-brace.js");
const pflagset = require("./p.flagset.js");
const pflagoption = require("./p.flagoption.js");
const pcomment = require("./p.comment.js");
// Get error checking functions.
const {
	issue,
	error: eerror,
	// Rename functions to later wrap.
	verify: everify,
	brace_check: ebc
} = require("./error.js");

module.exports = (contents, commandname, source) => {
	// Vars - Main loop.
	let i = 0;
	let l = contents.length;

	// Vars - Line information.
	let line_num = 1; // y-index
	let line_fchar; // x-index
	let indentation = "";

	// Vars - General.
	let lookup = {};
	let settings = {};
	let newlines = [];
	let warnings = [];

	// Vars - Parser flags.
	let line_type; // Store current type of line being parsed.
	let currentflag; // Store flag name of currently parsed flag list.
	let currentchain; // Store current command chain.

	// Vars - Tracking.
	let last_open_br; // Track open/closing brackets.
	let last_open_pr; // Track open/closing parentheses.
	let flag_count; // Track command's flag count.
	let flag_count_options; // Track flag's option count.

	// RegExp patterns:
	let r_letter = /[a-zA-Z]/; // Letter.
	let r_whitespace = /[ \t]/; // Whitespace.
	let r_nl = new RegExp(`(\\r?\\n)`); // New line character.
	let r_start_line_char = /[-@a-zA-Z\)\]#]/; // Starting line character.

	// Create error functions wrappers to add fixed parameters.
	let verify = result => {
		return everify(result, warnings, source);
	};
	let brace_check = (issue, brace_style) => {
		return ebc({
			issue,
			brace_style,
			last_open_br,
			last_open_pr,
			indentation,
			warnings,
			source
		});
	};
	let error = (...params) => {
		// Add source to parameters.
		params.push(source);
		// Run and return error function.
		return eerror.apply(null, params);
	};
	// Create parser wrapper to add fixed parameters.
	let parser = (pname, ...params) => {
		// Join fixed parameters with provided.
		params = [contents, i, l, line_num, line_fchar].concat(params);
		// Run parser function.
		return pname.apply(null, params);
	};

	// ACMAP file header.
	let header = [
		`# THIS FILE IS AUTOGENERATED —— DO NOT EDIT FILE DIRECTLY.`,
		`# ${new Date()};${Date.now()}`,
		`# nodecliac definition mapfiles: ~/.nodecliac/defs/\n`
	];

	// Main loop. Loops over each character in acmap.
	for (; i < l; i++) {
		// Cache current/previous/next chars.
		let char = contents.charAt(i);
		let pchar = contents.charAt(i - 1);
		let nchar = contents.charAt(i + 1);

		// Check if \r?\n newline sequence.
		if ((char === "\r" && nchar === "\n") || char === "\n") {
			// Reset vars.
			line_type = null;
			indentation = "";
			line_num++; // Increment line counter.
			line_fchar = null; // Reset line char index.

			// Note: The line type will get switched to "command_setter"
			// after extracting the command chain. However, when the command
			// chain is not assigned flags the command chain needs to be
			// cleared to catch any flags not contained within [].
			if (line_type === "command_setter") {
				currentchain = "";
			}

			continue;
		}

		// Store index of first character of current line to keep track of
		// the x-index character position.
		if (!line_fchar) {
			line_fchar = i;
		}

		// Determine the lines type to parse line accordingly.
		if (!line_type) {
			// If the current character is a space then continue.
			if (r_whitespace.test(char)) {
				indentation += char;
				continue;
			}

			// Line must begin with following start-of-line character:
			// @       → Setting.
			// #       → Comment.
			// a-zA-Z  → Command chain.
			// -       → Flag.
			// '- '    → Flag option (ignore quotes).
			// )       → Closing flag set.
			// ]       → Closing long-flag form.

			// If current flag is set only comments, flag options, and
			// closing parenthesis are allowed.
			if (currentflag) {
				switch (char) {
					case ")":
						line_type = "close_parenthesis";
						break;
					case "#":
						line_type = "comment";
						break;
					default:
						line_type = "flag_option";
				}
			} else {
				// Char must be an allowed starting char.
				if (!r_start_line_char.test(char)) {
					// Character index will be indentation.length + 1.
					error(char, 0, line_num, indentation.length + 1);
				}

				// Set line start type.
				// RegExp Switch case: [https://stackoverflow.com/a/2896642]
				switch (true) {
					case char === "@":
						line_type = "setting";
						break;
					case char === "#":
						line_type = "comment";
						break;
					case char === "]":
						line_type = "close_bracket";
						break;
					case char === "-":
						// If flag is set we are getting flag options.
						line_type = currentflag ? "flag_option" : "flag_set";

						// If command chain doesn't exist but a flag_set or
						// option was detected the line was illegally declared.
						if (!currentchain) {
							// Check for improperly declared flag/option.
							if (/[- \t]/.test(nchar)) {
								error("", nchar === "-" ? 4 : 3, line_num, 0);
							} else {
								// General error - invalid line.
								error("", 5, line_num, 0);
							}
						}

						break;
					case char === ")":
						line_type = "close_parenthesis";
						break;
					case r_letter.test(char):
						line_type = "command";

						// If a current chain flag is set then another chain
						// cannot be parsed. This means the chain is nested.
						if (currentchain) {
							error("", 1, line_num, 0);
						}

						break;
				}

				// Indentation/whitespace checks.
				if (indentation) {
					// Following commands cannot begin with any whitespace.
					if (/(setting|command)/.test(line_type)) {
						// Line cannot begin begin with whitespace.
						error("", 6, line_num, 0);
					}

					// Give warning for mixed whitespace
					if (/ /.test(indentation) && /\t/.test(indentation)) {
						// Add warning to warnings.
						warnings.push({
							line: line_num,
							index: 0,
							reason: `Mixed whitespace characters.`
						});
					}
				}
			}
		}

		// Run logic for each line type.
		switch (line_type) {
			case "setting":
				{
					// Parse and verify line.
					let result = verify(parser(psetting, settings));

					// Reset index to start at newline on next iteration.
					i = result.nl_index - 1;

					// Store setting/value pair.
					settings[result.name] = result.value;
				}

				break;
			case "command":
				{
					// Check for an unclosed '['.
					brace_check("unclosed", "[");

					// Parse and verify line.
					let result = verify(parser(pcommand));

					// Reset index to start at newline on next iteration.
					i = result.nl_index - 1;

					// Get command chain.
					let cc = result.chain;
					let value = result.value;
					// Get opening brace index.
					let br_index = result.br_open_index;

					// Store command chain.
					if (!lookup[cc]) {
						lookup[cc] = new Set();
					}
					// Store current command chain.
					currentchain = cc;

					// For non flag set one-liners.
					if (result.brstate) {
						// If brackets are empty set flags.
						if (result.brstate === "closed") {
							// Reset flags.
							currentchain = "";
							last_open_br = null;
						}
						// If bracket is unclosed set other flags.
						else {
							// Set flag set counter.
							flag_count = [line_num, 0];
							// Store line + opening bracket index.
							last_open_br = [line_num, br_index];
						}
					} else {
						// Clear values.
						currentchain = "";

						// Store flagsets with its command chain in lookup table.
						let chain = lookup[result.chain];
						if (chain) {
							// Get flag sets.
							let flags = result.flagsets;

							// Add each flag set to its command chain.
							for (let j = 0, ll = flags.length; j < ll; j++) {
								// Cache current loop item.
								let flag = flags[j].trim();

								// Skip empty flags.
								if (!/^-{1,}$/.test(flag)) {
									chain.add(flag);
								}
							}
						}
					}
				}

				break;
			case "flag_set":
				{
					// Check for an unclosed '('.
					brace_check("unclosed", "(");

					// Parse and verify line.
					let result = verify(parser(pflagset, indentation));

					// Breakdown flag.
					let hyphens = result.symbol;
					let flag = result.name;
					let setter = result.assignment;
					let values = result.value;
					let special = result.special;
					let isopeningpr = result.isopeningpr;
					// Get opening brace index.
					let pr_index = result.pr_open_index;

					// If we have a flag like '--flag=(' we have a long-form
					// flag list opening. Store line for later use in case
					// the parentheses is not closed.
					if (isopeningpr) {
						// Store line + opening parentheses index for use in error
						// later if needed.
						last_open_pr = [line_num, pr_index];
						currentflag = `${hyphens}${flag}`;
					}

					// Add to lookup table if not already.
					let chain = lookup[currentchain];
					if (chain) {
						// Add flag itself to lookup table > command chain.
						chain.add(`${hyphens}${flag}${setter}`);

						// It not an opening brace then add values.
						if (!isopeningpr) {
							// Loop over values and add to lookup table.
							for (let i = 0, l = values.length; i < l; i++) {
								// Cache current loop item.
								let value = values[i];

								// Add to lookup table > command chain.
								chain.add(`${hyphens}${flag}${setter}${value}`);
							}
						}
					}

					// Increment flag set counter.
					if (flag_count) {
						// Get values before incrementing.
						let [counter, linenum] = flag_count;
						// Increment and store values.
						flag_count = [linenum, counter + 1];
					}

					// Increment/set flag options counter.
					flag_count_options = [line_num, 0];

					// Reset index to start at newline on next iteration.
					i = result.nl_index - 1;
				}

				break;
			case "flag_option":
				{
					// Parse and verify line.
					let result = verify(parser(pflagoption, indentation));

					// Get result value.
					let value = result.value[0];

					// If flag chain exists add flag option and increment counter.
					let chain = lookup[currentchain];
					if (chain && value) {
						chain.add(`${currentflag}=${value}`);

						// Increment flag option counter.
						if (flag_count_options) {
							// Get values before incrementing.
							let [counter, linenum] = flag_count_options;
							// Increment and store values.
							flag_count_options = [linenum, counter + 1];
						}
					}

					// Reset index to start at newline on next iteration.
					i = result.nl_index - 1;
				}

				break;
			case "close_parenthesis":
				{
					// Opening flag must be set else this ')' is unmatched.
					brace_check("unmatched", ")");
					// If command chain's flag array is empty give warning.
					if (flag_count_options && !flag_count_options[1]) {
						brace_check("empty", "parentheses");
					}
					// Clear flag.
					flag_count_options = null;

					// Parse and verify line.
					let result = verify(parser(pbrace));

					// Reset flags.
					currentflag = null;
					last_open_pr = null;

					// Reset index to start at newline on next iteration.
					i = result.nl_index - 1;
				}

				break;
			case "close_bracket":
				{
					// Opening flag must be set else this ']' is unmatched.
					brace_check("unmatched", "]");
					// If command chain's flag array is empty give warning.
					if (flag_count && !flag_count[1]) {
						brace_check("empty", "brackets");
					}
					// Clear flag.
					flag_count = null;

					// Parse and verify line.
					let result = verify(parser(pbrace));

					// Reset flags.
					currentchain = "";
					last_open_br = null;

					// Reset index to start at newline on next iteration.
					i = result.nl_index - 1;
				}

				break;
			case "comment":
				{
					// Parse and verify line.
					let result = verify(parser(pcomment));

					// Reset index to start at newline on next iteration.
					i = result.nl_index - 1;
				}

				break;
		}
	}

	// Final unclosed brace checks.
	brace_check("unclosed", "[");
	brace_check("unclosed", "(");

	/**
	 * IIFE arrow function prints parser warnings.
	 *
	 * @return {undefined} - Nothing is returned.
	 *
	 * @resource [https://stackoverflow.com/a/8228308]
	 */
	// Track longest (line + index) column to evenly space line/char.
	let line_col_length = 0;
	(() => {
		// Order warnings by line number then issue.
		warnings = warnings.sort(function(a, b) {
			// Store line + index length;
			let line_col_size = (a.line + "" + (a.index || "")).length;
			if (line_col_size > line_col_length) {
				line_col_length = line_col_size;
			}

			// [https://coderwall.com/p/ebqhca/javascript-sort-by-two-fields]
			// [https://stackoverflow.com/a/13211728]
			return a.line - b.line || a.index - b.index;
		});

		// Add warnings header if warnings exist.
		if (warnings.length) {
			console.log();
			console.log(
				`${chalk.bold.underline(path.relative(process.cwd(), source))}`
			);
		}

		for (let i = 0, l = warnings.length; i < l; i++) {
			// Cache current loop item.
			issue(warnings[i], "warn", line_col_length);
		}

		// Print bottom padding.
		console.log();
	})();

	console.log("");
	console.log(chalk.bold.blue("LOOKUP:"));
	console.log(lookup);
	console.log("");
	console.log(chalk.bold.blue("SETTINGS:"));
	console.log(settings);
	console.log("");
	console.log(chalk.bold.blue("NEWLINES:"));

	for (let i = 0, l = newlines.length; i < l; i++) {
		// Cache current loop item.
		let line = newlines[i];

		console.log(line);
	}
	console.log("");

	exit([]);

	// // Return generated acdef/config file contents.
	// return {
	// 	acdef: header
	// 		.concat(
	// 			merge(commandname, lookup, newlines).sort(function(a, b) {
	// 				return a.localeCompare(b);
	// 			})
	// 		)
	// 		.join("\n")
	// 		.replace(/\s*$/, ""),
	// 	config: config(settings, header)
	// };
};
