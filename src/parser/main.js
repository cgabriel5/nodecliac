"use strict";

// Parser:
// ✓ comments
// 	✓ single line
// 	✖ trailing-ending comments
// ✓ @settings
// ✓ command chains
// 	✓ shortcuts
// ✓ long-form flags
// 	✓ command-flags
// 	✓ flags options list

// ✖ balanced braces - necessary?
// ✖ validate characters for command chains
// ✖ account for line numbers/errors

// Needed modules.
// const path = require("path");
const chalk = require("chalk");
const { exit } = require("../utils.js");

// Require parser functions.
const merge = require("./merge.js");
const config = require("./config.js");
const dedupe = require("./dedupe.js");
const argparser = require("./argparser.js");
const lookahead = require("./lookahead.js");
const shortcuts = require("./shortcuts.js");
const paramparse = require("./paramparse.js");
const formatflags = require("./formatflags.js");
// Get parsers.
const psetting = require("./p.setting.js");
const pcommand = require("./p.command.js");
const pbrace = require("./p.close-brace.js");
const pflagset = require("./p.flagset.js");
const pflagoption = require("./p.flagoption.js");

module.exports = (contents, commandname, source) => {
	// Vars - General.
	let line = "";
	let line_count = 0;
	let indentation = "";
	let lookup = {};
	let settings = {};
	let newlines = [];

	// Vars - Parser flags.
	let line_type; // Store current type of line being parsed.
	let mflag; // Store current flag.
	let commandchain; // Store current command chain.

	// Vars - Track open/closed brace vars.
	let last_open_br = [];
	let last_open_pr = [];
	let commandchain_flag_count;
	let flag_options_count;

	// RegExp patterns:
	// Letter.
	let r_letter = /[a-zA-Z]/;
	// Whitespace.
	let r_whitespace = /[ \t]/;
	// New line character.
	let r_nl = new RegExp(`(\\r?\\n)`);
	// Open command bracket.
	let r_open_command_br = /^\[\]?$/;
	// Close bracket.
	let r_close_br = /^[ \t]*\][ \t]*$/;
	// Close parentheses.
	let r_close_parens = /^[ \t]*\)[ \t]*$/;
	// Starting line character.
	let r_start_line_char = /[-@a-zA-Z\)\]#]/;
	// Command setter.
	let r_command_setter = /^[ \t]*=[ \t]*(\[|-{1,2})/;
	// Flag option.
	let r_flag_option = /^[ \t]*-[ \t]{1,}([^\s]{1,}.*?)$/;
	// Command.
	let r_command = new RegExp(`[-_.:a-zA-Z0-9\\\\\/{}\|]`);
	// Setting syntax.
	let r_setting = /^(@[a-zA-Z][_a-zA-Z]*)[ \t]*(=[ \t]*(.*?))?$/;
	// Flag set.
	let r_flag_set = /^(-{1,2})([a-zA-Z][-._:a-zA-Z0-9]*)[ \t]*((=\*?)[ \t]*(\(|\(\)|.*?)?)?$/;

	// acmap file header.
	let header = [
		`# THIS FILE IS AUTOGENERATED —— DO NOT EDIT FILE DIRECTLY.`,
		`# ${new Date()};${Date.now()}`,
		`# nodecliac definition mapfiles: ~/.nodecliac/defs/\n`
	];

	// The index, source input, regexp, return character count.
	let error = (message, index, line) => {
		// Use provided line num else use the currently parsed line number.
		let linenum = (line !== undefined ? line : line_count) + 1;
		let linechar = index !== undefined ? `:${index}` : "";

		exit([
			`[${chalk.bold.red(
				"error"
			)}] ${message} [line ${linenum}${linechar}]`
		]);
	};

	// The index, source input, regexp, return character count.
	let warning = (message, index, line) => {
		// Use provided line num else use the currently parsed line number.
		let linenum = (line !== undefined ? line : line_count) + 1;
		let linechar = index !== undefined ? `:${index}` : "";

		exit(
			[
				`[${chalk.bold.yellow(
					"warning"
				)}] ${message} [line ${linenum}${linechar}]`
			],
			false
		);
	};

	/**
	 * Issue warnings and or error the parsing result object might contain.
	 *
	 * @param  {object} result - The parsing result object.
	 * @return {undefined} - Logs warnings. Exits script if error is issued.
	 */
	let verify = result => {
		// Get warnings from result object.
		let { warnings } = result;
		// Print warnings.
		if (warnings.length) {
			for (let j = 0, ll = warnings.length; j < ll; j++) {
				issue(warnings[j], "warn");
			}
		}

		// Issue error if present.
		if (result.hasOwnProperty("code")) {
			issue(result);
		}
	};

	/**
	 * Issues warnings/error. Warnings are non-obtrusive as they simply get
	 *     logged to the console. When an error is issued the script will
	 *     exit after logging error to the console.
	 *
	 * @param  {object} data - The result object.
	 * @param  {string} type - The issue type (error/warning).
	 * @return {undefined} - Logs warnings. Exits script if error is issued.
	 */
	let issue = (result, type = "error") => {
		// Use provided line num else use the currently parsed line number.
		let linenum = (result.line || line_count) + 1;
		let linechar = result.index - result.offset + 1;

		// Determine color to highlight label.
		let color = type === "error" ? "red" : "yellow";

		// Build line info.
		let lineinfo = `line ${linenum}`;
		if (linechar !== undefined) {
			lineinfo += `:${linechar}`;
		}

		// Log issue to console.
		exit(
			[`[${chalk.bold[color](type)}] ${result.reason} [${lineinfo}]`],
			// If issuing an error stop script after logging error.
			type === "error" ? undefined : false
		);
	};

	// Main loop. Loops over each character in acmap.
	for (let i = 0, l = contents.length; i < l; i++) {
		// Cache current/previous/next chars.
		let char = contents.charAt(i);
		let pchar = contents.charAt(i - 1);
		let nchar = contents.charAt(i + 1);

		// Check if \r?\n newline sequence.
		if ((char === "\r" && nchar === "\n") || char === "\n") {
			// Increment line counter.
			line_count++;

			// The line type will get switched to "command_setter" after
			// extracting the command chain. However, when the command chain
			// does not contain a setter and therefore also no flags the
			// command chain needs to be cleared to catch any flags not
			// contained within [].
			if (line_type === "command_setter") {
				commandchain = "";
			}

			// Reset vars.
			line = "";
			line_type = null;
			indentation = "";

			continue;
		}

		// If a line type has not been defined yet.
		if (!line_type) {
			// If the current character is a space then continue.
			if (r_whitespace.test(char)) {
				indentation += char;
				continue;
			}

			// If not a space character, look for an allowed character.
			// Lines can start with following chars/char sets.
			// @      → setting
			// #      → comment
			// a-zA-Z → command chain
			//     -      → flag
			//     '- '   → flag option (ignore quotes)
			//     )      → closing flag set
			//     ]      → closing long-flag form
			// -------------------------------------------------------------
			// Special flag characters to look out for:
			// $(, "", ''

			// Char must be an allowed starting char.
			if (!r_start_line_char.test(char)) {
				error(
					`${chalk.bold(
						"Syntax"
					)}: Invalid start-of-line character '${char}'.`,
					indentation.length
				);
			}

			// Set line start type.
			if (char === "@") {
				line_type = "setting";
			} else if (char === "#") {
				line_type = "comment";
			} else if (r_letter.test(char)) {
				line_type = "command";

				if (commandchain) {
					error("Command chain cannot be nested.");
				}
			} else if (char === "]") {
				line_type = "close_bracket";
			} else if (char === "-") {
				// If flag is set we are getting flag options.
				line_type = mflag
					? // Option must my listed with a hyphen.
					  // /\s/.test(nchar)
					  "flag_option"
					: "flag_set";

				// If command chain does not exist but a flag_set/option
				// was detected there is an unnested/unwrapped flag/option.
				if (!commandchain) {
					// Look ahead to grab setting line.
					let { indices, chars_str } = lookahead(i, contents, r_nl);

					if (/^-[ \t]/.test(chars_str)) {
						error("Improperly nested flag option.");
					} else if (/^-{1,2}/) {
						error("Improperly nested flag.");
					}

					// General error.
					error(
						"Rogue flag/flag option. Must be placed inside '[]'."
					);
				}
			} else if (char === ")") {
				line_type = "close_parenthesis";
			}

			// Following commands cannot begin with any whitespace.
			if (
				indentation.length &&
				["setting", "command"].includes(line_type)
			) {
				error(`Line cannot begin with whitespace.`, 0);
			}

			// line += char;
		}

		if (line_type) {
			if (line_type === "setting") {
				// Parse line.
				let result = psetting(contents, i, settings);

				// Check result for parsing issues (errors/warnings).
				verify(result);

				// When parsing passes reset the index so that on the next
				// iteration it continues with the newline character.
				i = result.nl_index - 1;

				// Store setting/value pair.
				settings[result.name] = result.value;
			} else if (line_type === "command") {
				// Parse line.
				let result = pcommand(contents, i);

				// Check result for parsing issues (errors/warnings).
				verify(result);

				// When parsing passes reset the index so that on the next
				// iteration it continues with the newline character.
				i = result.nl_index - 1;

				// Get command chain.
				let cc = result.chain;
				let value = result.value;

				// Store command chain.
				if (!lookup[cc]) {
					lookup[cc] = [];
				}
				commandchain = cc;

				// Unclosed '['.
				if (last_open_br.length) {
					line_count = last_open_br[0];
					error("Unclosed open bracket.");
				}

				// For non flagset oneliners.
				if (result.brstate) {
					// If brackets are empty set flags.
					if (result.brstate === "closed") {
						// Reset flags.
						commandchain = "";
						last_open_br.length = 0;
					}
					// If bracket is unclosed set other flags.
					else {
						// Store line of open bracket for later use in error.
						last_open_br = [line_count];

						// Set flag set counter.
						commandchain_flag_count = [line_count, 0];
					}
				} else {
					// Clear values.
					commandchain = "";

					// Store flagsets with its command chain in lookup table.
					let chain = lookup[result.chain];
					if (chain) {
						// Get flag sets.
						let flags = result.flagsets;

						// Add each flag set to its command chain.
						for (let j = 0, ll = flags.length; j < ll; j++) {
							// Cache current loop item.
							let flag = flags[j].trim();

							// Skip empty flags.
							if (!/^-{1,}$/.test(flag)) {
								chain.push(flag);
							}
						}
					}
				}
			} else if (line_type === "flag_set") {
				// Parse line.
				let result = pflagset(contents, i, indentation);

				// Check result for parsing issues (errors/warnings).
				verify(result);

				// // Must pass RegExp pattern.
				// if (!r_flag_set.test(chars_str)) {
				// 	// Check if it's a flag option. If so the option is not
				// 	// being assigned to a flag.
				// 	if (r_flag_option.test(chars_str)) {
				// 		error(`Unassigned flag option.`);
				// 	}
				// 	// General error.
				// 	error(`Invalid flag.`);
				// }

				// Breakdown flag.
				let hyphens = result.symbol;
				let flag = result.name;
				let setter = result.assignment;
				let values = result.value;
				let special = result.special;
				let isopeningpr = result.isopeningpr;

				// If we have a flag like '--flag=(' we have a long-form
				// flag list opening. Store line for later use in case
				// the parentheses is not closed.
				if (isopeningpr) {
					// Unclosed '('.
					if (last_open_pr.length) {
						line_count = last_open_pr[0];
						error("Unclosed open parentheses.");
					}

					// Store line of open bracket for later use in error.
					last_open_pr = [line_count];
					mflag = `${hyphens}${flag}`;
				}

				// Add to lookup table if not already.
				let chain = lookup[commandchain];
				if (chain) {
					// Add flag itself to lookup table > command chain.
					chain.push(`${hyphens}${flag}${setter}`);

					// It not an opening brace then add values.
					if (!isopeningpr) {
						// Loop over values and add to lookup table.
						for (let i = 0, l = values.length; i < l; i++) {
							// Cache current loop item.
							let value = values[i];

							// Add to lookup table > command chain.
							chain.push(`${hyphens}${flag}${setter}${value}`);
						}
					}
				}

				// Increment flag set counter.
				if (commandchain_flag_count) {
					// Get values before incrementing.
					let [counter, linenum] = commandchain_flag_count;
					// Increment and store values.
					commandchain_flag_count = [linenum, counter + 1];
				}

				// Increment/set flag options counter.
				flag_options_count = [line_count, 0];

				// When parsing passes reset the index so that on the next
				// iteration it continues with the newline character.
				i = result.nl_index - 1;
			} else if (line_type === "flag_option") {
				// Parse line.
				let result = pflagoption(contents, i, indentation);
				// Get result value.
				let value = result.value[0];

				// Check result for parsing issues (errors/warnings).
				verify(result);

				// If flag chain exists add flag option and increment counter.
				let chain = lookup[commandchain];
				if (chain && value) {
					chain.push(`${mflag}=${value}`);

					// Increment flag option counter.
					if (flag_options_count) {
						// Get values before incrementing.
						let [counter, linenum] = flag_options_count;
						// Increment and store values.
						flag_options_count = [linenum, counter + 1];
					}
				}

				// When parsing passes reset the index so that on the next
				// iteration it continues with the newline character.
				i = result.nl_index - 1;
			} else if (line_type === "close_parenthesis") {
				if (!mflag) {
					error(`Unmatched closing parentheses.`);
				}

				// If command chain's flag array is empty give warning.
				if (flag_options_count && !flag_options_count[1]) {
					warning(
						`Empty '()' (no flag options).`,
						undefined,
						last_open_pr[0]
						// flag_options_count[1]
					);
				}
				// Clear flag.
				flag_options_count = null;

				// Parse line.
				let result = pbrace(contents, i);

				// Check result for parsing issues (errors/warnings).
				verify(result);

				// Reset flags.
				mflag = null;
				last_open_pr.length = 0;

				// When parsing passes reset the index so that on the next
				// iteration it continues with the newline character.
				i = result.nl_index - 1;
			} else if (line_type === "close_bracket") {
				// Unmatched ']'.
				if (!last_open_br.length) {
					error(`Unmatched closing bracket.`);
				}

				// If command chain's flag array is empty give warning.
				if (commandchain_flag_count && !commandchain_flag_count[1]) {
					warning(
						`Empty '[]' (no flags).`,
						void 0,
						last_open_br[0]
						// commandchain_flag_count[1]
					);
				}
				// Clear flag.
				commandchain_flag_count = null;

				// Parse line.
				let result = pbrace(contents, i);

				// Check result for parsing issues (errors/warnings).
				verify(result);

				// Reset flags.
				commandchain = "";
				last_open_br.length = 0;

				// When parsing passes reset the index so that on the next
				// iteration it continues with the newline character.
				i = result.nl_index - 1;
			} else if (line_type === "comment") {
				// Reset index to comment ending newline index.
				let la = lookahead(i, contents, r_nl);
				i = la.indices[1] - 1;
			}
		}
	}

	// If flags are still set post loop, a brace remained opened.
	// Unclosed '['.
	if (last_open_br.length) {
		line_count = last_open_br[0];
		error("Unclosed open bracket.");
	}
	// Unclosed '('.
	if (last_open_pr.length) {
		line_count = last_open_pr[0];
		error("Unclosed open parentheses.");
	}

	console.log("");
	console.log(chalk.bold.blue("LOOKUP:"));
	console.log(lookup);
	console.log("");
	console.log(chalk.bold.blue("SETTINGS:"));
	console.log(settings);
	console.log("");
	console.log(chalk.bold.blue("NEWLINES:"));

	for (let i = 0, l = newlines.length; i < l; i++) {
		// Cache current loop item.
		let line = newlines[i];

		console.log(line);
	}
	console.log("");

	exit([]);

	// // Return generated acdef/config file contents.
	// return {
	// 	acdef: header
	// 		.concat(
	// 			merge(commandname, lookup, newlines).sort(function(a, b) {
	// 				return a.localeCompare(b);
	// 			})
	// 		)
	// 		.join("\n")
	// 		.replace(/\s*$/, ""),
	// 	config: config(settings, header)
	// };
};
