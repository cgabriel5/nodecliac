"use strict";

// Parser:
// ✓ comments
// 	✓ single line
// 	✖ trailing-ending comments
// ✓ @settings
// ✓ command chains
// 	✓ shortcuts
// ✓ long-form flags
// 	✓ command-flags
// 	✓ flags options list

// ✖ balanced braces - necessary?
// ✖ validate characters for command chains
// ✖ account for line numbers/errors

// Needed modules.
// const path = require("path");
const chalk = require("chalk");
const { exit } = require("../utils.js");

// Require parser functions.
const config = require("./config.js");
const shortcuts = require("./shortcuts.js");
const dedupe = require("./dedupe.js");
const argparser = require("./argparser.js");
const formatflags = require("./formatflags.js");
const merge = require("./merge.js");

module.exports = (contents, commandname, source) => {
	// Vars - General.
	let line = "";
	let line_count = 0;
	let indentation = "";
	let lookup = {};
	let settings = {};
	let newlines = [];

	// let open_bracket = false;
	// let open_parenth = false;

	let commandchain;
	let mflag;
	let mcommand;
	let line_type;

	// acmap file header.
	let header = [
		`# THIS FILE IS AUTOGENERATED —— DO NOT EDIT FILE DIRECTLY.`,
		`# ${new Date()};${Date.now()}`,
		`# nodecliac definition mapfiles: ~/.nodecliac/defs/\n`
	];

	// Check if provided char is a space.
	let isspace = char => {
		return /[ \t]/.test(char);
	};

	// The index, source input, regexp, return character count.
	let lookahead = (index, input, r, rcount) => {
		let passed = false;
		let chars = [];
		let xchars = [];
		let indices = [];
		let sindex;
		let eindex;

		if (rcount === Infinity) {
			for (let i = index, l = input.length; i < l; i++) {
				// Cache current loop item.
				let char = input[i];

				if (r.test(char)) {
					if (sindex === undefined) {
						sindex = i;
					}

					chars.push(char);
				} else {
					eindex = i - 1;
					// Stop loop as all needed chars have been retrieved.
					break;
				}
			}
		} else {
			for (let i = index, l = input.length; i < l; i++) {
				// Cache current loop item.
				let char = input[i];

				if ((r.test(char) || passed) && rcount) {
					if (sindex === undefined) {
						sindex = i;
					}

					passed = true;
					chars.push(char);
					rcount--;
				} else if (!rcount) {
					eindex = i - 1;
					// Stop loop as all needed chars have been retrieved.
					break;
				} else {
					xchars.push(char);
				}
			}
		}

		if (sindex) {
			indices.push(sindex, eindex);
		}

		return { chars, xchars, indices };
	};

	// The index, source input, regexp, return character count.
	let error = (message, index) => {
		exit([
			"",
			`${chalk.bold.red("Error")} → ${chalk.bold(
				"Syntax"
			)}: ${message} (line ${line_count + 1}${index ? `:${index}` : ""})`,
			""
		]);
	};

	// Main loop. Loops over each character in acmap.
	for (let i = 0, l = contents.length; i < l; i++) {
		// Cache current/previous/next chars.
		let char = contents.charAt(i);
		let pchar = contents.charAt(i - 1);
		let nchar = contents.charAt(i + 1);

		// Check if \r?\n newline sequence.
		if ((char === "\r" && nchar === "\n") || char === "\n") {
			// Increment line counter.
			line_count++;

			// Reset vars.
			line = "";
			line_type = null;
			indentation = "";
		}
		// All other characters.
		else {
			// If line is empty look for allowed character.
			if (!line_type) {
				// If the current character is a space then continue.
				if (isspace(char)) {
					indentation += char;
					continue;
				}

				// If not a space character, look for an allowed character.
				// Lines can start with following chars/char sets.
				// @      → setting
				// #      → comment
				// a-zA-Z → command chain
				//     -      → flag
				//     '- '   → flag option (ignore quotes)
				//     )      → closing flag set
				//     ]      → closing long-flag form
				// -------------------------------------------------------------
				// Special flag characters to look out for:
				// $(, "", ''

				// // Look ahead for the first non space char.
				// let { chars: fchars, indices } = lookahead(
				// 	i,
				// 	contents,
				// 	new RegExp(`([^ \t]|\\r?\\n)`),
				// 	1
				// );

				// Char must be an allowed starting char.
				if (!/[-@a-z\)\]#]/i.test(char)) {
					error(`Invalid starting line character '${char}'`, i);
				}

				// Set line start type.
				if (char === "@") {
					line_type = "setting";

					if (/\r?\n/.test(nchar)) {
						// The setting name is missing.
						error("Dangling '@' setting identifier.");
					}
				} else if (char === "#") {
					line_type = "comment";

					if (/\r?\n/.test(nchar)) {
						// The setting name is missing.
						error("Dangling '#' comment identifier.");
					}
				} else if (/[a-zA-Z]/.test(char)) {
					line_type = "command";
				} else if (char === "-") {
					if (/\r?\n/.test(nchar)) {
						// The setting name is missing.
						error("Dangling '-' flag/option identifier.");
					}

					// If mflag is set we are getting flag options.
					line_type = mflag ? "flag_option" : "flag_set";

					// Empty flag option check.
					if (mflag && (nchar === "\n" || nchar === "\r")) {
						error(`Empty flag option`, 0);
					}
				} else if (char === ")") {
					if (!mflag) {
						error(`Unmatched closing parentheses`, 0);
					}

					line_type = "close_parenthesis";
					line += char;
					i--;
					continue;
				} else if (char === "]") {
					if (!mcommand) {
						error(`Unmatched closing bracket`, 0);
					}

					line_type = "close_bracket";
					line += char;
					i--;
					continue;
				}

				line += char;
			} else {
				if (line_type === "setting") {
					// Setting syntax:
					let r = /^(@[a-zA-Z][_a-zA-Z]*)[ \t]*(=[ \t]*(.*?))?$/;

					// Look ahead to grab setting line.
					let { chars: fchars, xchars, indices } = lookahead(
						i,
						contents,
						new RegExp(`(\\r?\\n)`),
						1
					);

					// Get all setting line chars.
					let lchars = xchars.join("");
					let sline = `@${lchars}`;

					// Checks:
					// - Empty setting.
					// - Invalid characters.
					// - Improperly quoted value.

					// Breakdown setting (setting name/value).
					let matches = sline.match(r);
					// If matches are not returned then the setting
					// name contains invalid characters.
					if (!matches) {
						// let setting_name = sline.match(/^[^ =]*/)[0];
						error(
							`Setting '${chalk.bold(
								sline.replace(
									/([^@a-zA-Z])/g,
									`${chalk.bold.red("$1")}`
								)
							)}' contains invalid characters.`
						);
					}
					// Check that if value is quoted is quoted properly.
					if (sline.includes("=")) {
						let [, value] = sline.match(/^.*?=[ \t*](.*?)$/);
						let val_fchar = value.charAt(0);
						var val_lchar = value.charAt(value.length - 1);
						if (/"|'/.test(val_fchar)) {
							// Check that the last char is a matching quote.
							if (val_fchar !== val_lchar) {
								error(`Improperly quoted setting value.`);
							}
						} else if (/"|'/.test(val_lchar)) {
							// Check that the last char is a matching quote.
							if (val_lchar !== val_fchar) {
								error(`Improperly quoted setting value.`);
							}
						}
					} else {
						error(`Setting not assigned a value.`);
					}
					// Check if setting syntax is valid or give general error.
					if (!r.test(sline)) {
						error(`Invalid setting`, indices[0]);
					}

					// Else, checks passed so reset vars. Reset index to be
					// at the end of the line.
					i = indices[0] - 1;

					// Store line.
					newlines.push((line += lchars));
				} else if (line_type === "command") {
					// Look ahead to grab command chain.
					let { chars: fchars, xchars, indices } = lookahead(
						i,
						contents,
						new RegExp(`[-_.:a-zA-Z0-9\\\\\/{}\|]`),
						Infinity
					);

					// Command length checks?

					// Reset index to be at the end of the line.
					i = indices[1];

					// Next look for command setter (' = ' → ignore quotes).
					line_type = "command_setter";

					// Store chars.
					line += fchars.join("");

					// Store command chain.
					if (!lookup[line]) {
						lookup[line] = [];
					}

					commandchain = line;
				} else if (line_type === "command_setter") {
					// Setting syntax:
					let r = /^[ \t]*=[ \t]*\[$/;

					// Look ahead to grab command chain.
					let indices_o = lookahead(
						i,
						contents,
						new RegExp(`[ \t=]`),
						Infinity
					).indices;

					// Look ahead to grab command chain.
					let { chars: fchars, xchars, indices } = lookahead(
						i,
						contents,
						new RegExp(`(\\r?\\n)`),
						1
					);

					// Get all setting line chars.
					let lchars = xchars.join("");

					// Check if has invalid character.
					// Highlight multiple '=' and '[' characters?
					if (!r.test(`${lchars}`)) {
						if (!lchars.includes("=")) {
							error(`Missing '='.`, indices[0]);
						}
						if (!lchars.includes("[")) {
							error(`Missing '['.`, indices[0]);
						}

						// Check for possible invalid characters.
						if (/([^ \t=\[\]])/.test(lchars)) {
							error(
								`Invalid characters '${chalk.bold(
									lchars.replace(
										/([^ \t=\[])/g,
										`${chalk.bold.red("$1")}`
									)
								)}'.`,
								indices[0]
							);
						} else {
							// Must be '=[' or '=[]' once spaces are removed.
							if (!/=\[\]?/.test(lchars.replace(/\s/g, ""))) {
								error(
									`Use command setter sequence '${chalk.bold(
										"= ["
									)}' instead (spaces optional).`
								);
							}
						}
					}

					// Reset index to be at the end of the line.
					i = indices_o[1];

					// Next look for command open bracket. ('[' → ignore quotes).
					line_type = "command_open_bracket";
				} else if (line_type === "command_open_bracket") {
					let chars, fchars, xchars, indices, la;

					// Look ahead to grab command chain.
					la = lookahead(i, contents, new RegExp(`\\[`), 1);
					fchars = la.chars;
					xchars = la.xchars;
					indices = la.indices;

					let open_index = indices[1];

					// Reset index to be at the end of the line.
					i = open_index;

					// Look ahead once more. We can only have 3 situations:
					// 1 - There are no more characters (excluding spaces).
					// 2 - There is a closing bracket ']'.
					// 3 - There are other chars unallowed chars.

					// Look ahead to grab...
					la = lookahead(i + 1, contents, new RegExp(`(\\r?\\n)`), 1);
					fchars = la.chars;
					xchars = la.xchars;
					indices = la.indices;

					let close_index = indices[1];

					// Remaining chars after open bracket '['.
					let rchars = xchars.join("").trim();
					if (/[^\]]/.test(rchars)) {
						error(
							`Invalid characters after open bracket '['`,
							indices[0]
						);
					}

					if (rchars === "]") {
						line += " --";
						// Reset index to be at the end of the line.
						i = indices[0] - 1;
					} else {
						// Set type to flags.
						mcommand = true;
					}

					// Store line.
					newlines.push(line);
				} else if (line_type === "flag_set") {
					// Setting syntax:
					let r = /^-{1,2}([a-zA-Z][-_:a-zA-Z0-9]*)[ \t]*(=\*?[ \t]*(\(|\(\))?)?$/;

					// Look ahead to grab setting.
					let { chars: fchars, xchars, indices } = lookahead(
						i,
						contents,
						new RegExp(`(\\r?\\n)`),
						1
					);

					// Get all setting line chars.
					let lchars = xchars.join("");

					// Check if setting syntax is valid give general error.
					if (!r.test(`-${lchars}`)) {
						// Further breakdown exact syntax error?
						// - setting name check?
						// - value check (if quoted is it properly quoted.)
						error(`Invalid flag`, indices[0]);
					}

					let chain = lookup[commandchain];
					if (chain) {
						// chain.push(`-${lchars}`);
						chain.push(`-${lchars.replace(/[\(\)]/g, "")}`);
					}

					if (lchars.includes("(") && !lchars.includes(")")) {
						// open_parenth = true;
						mflag = `-${lchars.replace(/[\=\*\(]/g, "")}`;
					}

					// Else it's a valid setting so reset vars.
					// Reset index to be at the end of the line.
					i = indices[0] - 1;

					// Store line.
					newlines.push((line += lchars));
				} else if (line_type === "flag_option") {
					// Flag option syntax:
					let r = /^[ \t]*-[ \t]*(.{2,})$/;

					// Look ahead to grab setting.
					let { chars: fchars, xchars, indices } = lookahead(
						i,
						contents,
						new RegExp(`(\\r?\\n)`),
						1
					);

					// Get all setting line chars.
					let lchars = xchars.join("");

					// Check if setting syntax is valid give general error.
					if (!r.test(`-${lchars}`)) {
						// Further breakdown exact syntax error?
						// - setting name check?
						// - value check (if quoted is it properly quoted.)
						error(`Invalid flag option`, indices[0]);
					}

					let chain = lookup[commandchain];
					if (chain) {
						chain.push(`${mflag}=${lchars.trim()}`);
					}

					// if (lchars.includes("(") && !lchars.includes(")")) {
					// 	// open_parenth = true;
					// 	mflag = `-${lchars.replace(/[\=\*\(]/g, "")}`;
					// }

					// Else it's a valid setting so reset vars.
					// Reset index to be at the end of the line.
					i = indices[0] - 1;

					// Store line.
					newlines.push((line += lchars));
				} else if (line_type === "close_parenthesis") {
					// Flag option syntax:
					let r = /^[ \t]*\)[ \t]*$/;

					// if (mflag) {
					// 	error(`Unmatched closing parentheses`, 0);
					// }

					// Look ahead to grab setting.
					let { chars: fchars, xchars, indices } = lookahead(
						i,
						contents,
						new RegExp(`(\\r?\\n)`),
						1
					);

					// Get all setting line chars.
					let lchars = xchars.join("");

					// Check if setting syntax is valid give general error.
					if (!r.test(`${lchars}`)) {
						// Further breakdown exact syntax error?
						// - setting name check?
						// - value check (if quoted is it properly quoted.)
						error(`Invalid closing parentheses.`, indices[0]);
					}

					// Reset flags.
					mflag = null;

					// Else it's a valid setting so reset vars.
					// Reset index to be at the end of the line.
					i = indices[0] - 1;

					// Store line.
					newlines.push(line);
				} else if (line_type === "close_bracket") {
					// Flag option syntax:
					let r = /^[ \t]*\][ \t]*$/;

					// Look ahead to grab setting.
					let { chars: fchars, xchars, indices } = lookahead(
						i,
						contents,
						new RegExp(`(\\r?\\n)`),
						1
					);

					// Get all setting line chars.
					let lchars = xchars.join("");

					// Check if setting syntax is valid give general error.
					if (!r.test(`${lchars}`)) {
						// Further breakdown exact syntax error?
						// - setting name check?
						// - value check (if quoted is it properly quoted.)
						error(`Invalid closing bracket.`, indices[0]);
					}

					// Reset flags.
					mcommand = null;

					// Else it's a valid setting so reset vars.
					// Reset index to be at the end of the line.
					i = indices[0] - 1;

					// Store line.
					newlines.push(line);
				} else if (line_type === "comment") {
					// Get all line characters and rest index.

					// Comment syntax:
					let r = /^#.*?$/;

					// Look ahead to grab comment ending.
					let { xchars, indices } = lookahead(
						i,
						contents,
						new RegExp(`(\\r?\\n)`),
						1
					);

					// Get all comment line chars.
					let lchars = xchars.join("");

					// Reset index to be at the end of the line.
					i = indices[0] - 1;

					// Don't store line.
				}
			}
		}
	}

	// Need to get line numbers.
	if (mcommand) {
		error(`Unclosed '['.`);
	}
	if (mflag) {
		error(`Unclosed '('.`);
	}

	console.log(lookup);

	// for (let i = 0, l = newlines.length; i < l; i++) {
	// 	// Cache current loop item.
	// 	let line = newlines[i];

	// 	console.log(line);
	// }

	exit([]);

	// // Return generated acdef/config file contents.
	// return {
	// 	acdef: header
	// 		.concat(
	// 			merge(commandname, lookup, newlines).sort(function(a, b) {
	// 				return a.localeCompare(b);
	// 			})
	// 		)
	// 		.join("\n")
	// 		.replace(/\s*$/, ""),
	// 	config: config(settings, header)
	// };
};
